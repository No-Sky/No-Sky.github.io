<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://no-sky.github.io/images/favicon.ico><meta name=robots content="noodp"><meta name=author content="nosky"><meta name=description content="nosky 的个人学习笔记"><meta name=keywords content="[note 笔记 nosky]"><link rel=prev href=https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E4%B8%83/><link rel=next href=https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E4%B9%9D/><link rel=canonical href=https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%85%AB/><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Oracle笔记 （八） | Note</title><meta name=title content="Oracle笔记 （八） | Note"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/no-sky.github.io"},"articleSection":"posts","name":"Oracle笔记 （八）","headline":"Oracle笔记 （八）","description":"子查询、集合运算 一、子查询 通过把一个查询的结果作为另一个查询的一部分,子查询一般出现在SELECT语句的WHERE子句中，Oracle也支持在FROM或HAVING子句中出现子查询。 子查询比主查询先执行，结果作为主查询的条件，在书写上要用圆括号扩起来，并放在比较运算符的右侧。\n1、单行子查询 如：查询比SCOTT工资高的雇员名字和工资。\nselect ename,sal from emp where sal\x26gt;(select sal from emp where empno=7788); 2、多行子查询* 如果子查询返回多行的结果，则我们称它为多行子查询。多行子查询要使用不同的比较运算符号，它们是IN、ANY和ALL。\n如:查询工资低于任意一个“CLERK”的工资的雇员信息。\nselect empno,ename,job,sal from emp where sal \x26lt; any (select sal from emp where job = \x26#39;CLERK\x26#39;) and job \x26lt;\x26gt; \x26#39;CLERK\x26#39;; 如：\t查询工资比所有的“SALESMAN”都高的雇员的编号、名字和工资。\nselect empno,ename,job from emp where job in (select job from emp where deptno = 10) and deptno = 20; 3.多列子查询 **如果子查询返回多列，则对应的比较条件中也应该出现多列，这种查询称为多列子查询。以下是多列子查询的训练实例。 ** 如： 查询职务和部门与SCOTT相同的雇员的信息。\nselect empno, ename,sal from emp where (job,deptno) = (select job,deptno from emp where empno = 7788); 4．在FROM从句中使用子查询 在FROM从句中也可以使用子查询，在原理上这与在WHERE条件中使用子查询类似。有的时候我们可能要求从雇员表中按照雇员出现的位置来检索雇员，很容易想到的是使用rownum虚列。比如我们要求显示雇员表中6～9位置上的雇员，可以用以下方法","inLanguage":"en-us","author":"nosky","creator":"nosky","publisher":"nosky","accountablePerson":"nosky","copyrightHolder":"nosky","copyrightYear":"2017","datePublished":"2017-11-28 19:10:30 \x2b0000 UTC","dateModified":"2017-11-28 19:10:30 \x2b0000 UTC","url":"https:\/\/no-sky.github.io\/2017\/oracle%E7%AC%94%E8%AE%B0-%E5%85%AB\/","wordCount":"139","keywords":["oracel","Note"]}</script><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\[','\]']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}},"HTML-CSS":{linebreaks:{automatic:true}},SVG:{linebreaks:{automatic:true}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://no-sky.github.io>Note</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>Blog</a>
<a class=menu-item href=/tags/>Tags</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://no-sky.github.io>Note</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>Blog</a>
<a class=menu-item href=/tags/>Tags</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">Oracle笔记 （八）</h1><div class=post-meta>Written by <a itemprop=name href=https://no-sky.github.io rel=author>nosky</a> with ♥
<span class=post-time>on <time datetime=2017-11-28 itemprop=datePublished>November 28, 2017</time></span>
in</div></header><div class=post-content><h1 id=heading>子查询、集合运算</h1><h2 id=heading1>一、子查询</h2><p><strong>通过把一个查询的结果作为另一个查询的一部分,子查询一般出现在SELECT语句的WHERE子句中，Oracle也支持在FROM或HAVING子句中出现子查询。
子查询比主查询先执行，结果作为主查询的条件，在书写上要用圆括号扩起来，并放在比较运算符的右侧。</strong></p><h3 id=1>1、单行子查询</h3><p>如：查询比SCOTT工资高的雇员名字和工资。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=color:#66d9ef>select</span> ename,sal <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> sal<span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>select</span> sal <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> empno<span style=color:#f92672>=</span><span style=color:#ae81ff>7788</span>);
</code></pre></div><h3 id=2>2、多行子查询*</h3><p><strong>如果子查询返回多行的结果，则我们称它为多行子查询。多行子查询要使用不同的比较运算符号，它们是IN、ANY和ALL。</strong></p><p>如:查询工资低于任意一个“CLERK”的工资的雇员信息。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=color:#66d9ef>select</span> empno,ename,job,sal <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> sal <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>any</span> (<span style=color:#66d9ef>select</span> sal <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> job <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;</span><span style=color:#e6db74>CLERK</span><span style=color:#e6db74>&#39;</span>) <span style=color:#66d9ef>and</span> job <span style=color:#f92672>&lt;</span><span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#39;</span><span style=color:#e6db74>CLERK</span><span style=color:#e6db74>&#39;</span>;
</code></pre></div><p>如： 查询工资比所有的“SALESMAN”都高的雇员的编号、名字和工资。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=color:#66d9ef>select</span> empno,ename,job <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> job <span style=color:#66d9ef>in</span> (<span style=color:#66d9ef>select</span> job <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> deptno <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>) <span style=color:#66d9ef>and</span> deptno <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
</code></pre></div><h3 id=3>3.多列子查询</h3><p>**如果子查询返回多列，则对应的比较条件中也应该出现多列，这种查询称为多列子查询。以下是多列子查询的训练实例。
**
如： 查询职务和部门与SCOTT相同的雇员的信息。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=color:#66d9ef>select</span> empno, ename,sal <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> (job,deptno) <span style=color:#f92672>=</span> (<span style=color:#66d9ef>select</span> job,deptno <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> empno <span style=color:#f92672>=</span> <span style=color:#ae81ff>7788</span>);
</code></pre></div><h3 id=4from>4．在FROM从句中使用子查询</h3><p><strong>在FROM从句中也可以使用子查询，在原理上这与在WHERE条件中使用子查询类似。有的时候我们可能要求从雇员表中按照雇员出现的位置来检索雇员，很容易想到的是使用rownum虚列。比如我们要求显示雇员表中6～9位置上的雇员，可以用以下方法</strong></p><p>如：查询雇员表中排在第6～9位置上的雇员。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=color:#66d9ef>select</span> ename, sal, <span style=color:#66d9ef>from</span> (<span style=color:#66d9ef>select</span> rownum <span style=color:#66d9ef>as</span> num,ename,sal <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> rownum<span style=color:#f92672>&lt;</span><span style=color:#f92672>=</span><span style=color:#ae81ff>9</span>) <span style=color:#66d9ef>where</span> num<span style=color:#f92672>&gt;</span><span style=color:#f92672>=</span><span style=color:#ae81ff>6</span>;
</code></pre></div><h2 id=heading2>二、集合运算</h2><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>union</td><td>并集，合并两个操作的结果，去掉重复的部分</td></tr><tr><td>union all</td><td>并集，合并两个操作的结果，保留重复的部分</td></tr><tr><td>minus</td><td>差集，从前面的操作结果中去掉与后面操作结果相同的部分</td></tr><tr><td>intersect</td><td>交集，取两个操作结果中相同的部分</td></tr></tbody></table><p>如：查询部门10和部门20的所有职务。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=color:#66d9ef>select</span> job <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> deptno <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span> 
<span style=color:#66d9ef>union</span>
<span style=color:#66d9ef>select</span> job <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> deptno <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
</code></pre></div><p>如：查询只在部门表中出现，但没有在雇员表中出现的部门编号。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=color:#66d9ef>select</span> deptno <span style=color:#66d9ef>from</span> dept
minus
<span style=color:#66d9ef>select</span> deptno <span style=color:#66d9ef>from</span> emp;
</code></pre></div></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>nosky</span></p><p class=copyright-item><span>Link:</span>
<a href=https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%85%AB/>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%85%AB/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://no-sky.github.io/tags/oracel/>#oracel</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://no-sky.github.io>home</a></span></section></div><div class=post-nav><a href=https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E4%B8%83/ class=prev rel=prev title="Oracle笔记 （七）"><i class="iconfont icon-left"></i>&nbsp;Oracle笔记 （七）</a>
<a href=https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E4%B9%9D/ class=next rel=next title="Oracle笔记 （九）">Oracle笔记 （九）&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2016 - 2020</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://no-sky.github.io>nosky</a> |</span>
<a href=http://beian.miit.gov.cn/ target=_blank rel="external nofollow">湘ICP备19027112号</a> |
<a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=43042102000116" rel="external nofollow"><img src=/images/beian.png>湘公网安备 43042102000116号</a> |
<span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow">Hugo</a> & <a href=https://github.com/liuzc/leaveit target=_blank rel="external nofollow">LeaveIt</a></span></br><span><a href=https://www.upyun.com/><img style=width:80px;height:30px;background-color:#70847d src=/images/upyun.png alt></a></span></div></footer><script src=/js/vendor_no_gallery.min.js async></script></div></body></html>