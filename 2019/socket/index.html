<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://no-sky.github.io/images/favicon.ico><meta name=robots content="noodp"><meta name=author content="nosky"><meta name=description content="nosky 的个人学习笔记"><meta name=keywords content="[note 笔记 nosky]"><link rel=prev href=https://no-sky.github.io/2019/icmp-protocol/><link rel=next href=https://no-sky.github.io/2019/http/><link rel=canonical href=https://no-sky.github.io/2019/socket/><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Socket编程 | Note</title><meta name=title content="Socket编程 | Note"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/no-sky.github.io"},"articleSection":"posts","name":"Socket编程","headline":"Socket编程","description":"基于 TCP 和 UDP 协议的 Socket 编程 客户端与服务端在通信之前，双方都要建立一个Socket。 在建立 Socket 的时候，应该设置Socket 函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。Socket 编程进行的是端到端的通信，往往意识不到中间经过多少局域网，多少路由器，因而能够设置的参数，也只能是端到端协议之上网络层和传输层的。在网络层，还记得咱们前面讲过的，TCP 协议是基于数据流的，所以设置为SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM。\n基于 TCP 协议的 Socket 程序函数调用过程 TCP 的服务端要先监听一个端口，一般是先调用 bind 函数，给这个 Socket 赋予一个 IP 地址和端口。当服务端有了 IP 和端口号，就可以调用 listen 函数进行监听。在 TCP 的状态图里面，有一个 listen 状态，当调用这个函数之后，服务端就进入了这个状态，这个时候客户端就可以发起连接了。\n在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完 毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态。 接下来，服务端调用 accept 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。 在服务端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接的 IP 地址和端 口号，然后开始发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept 就会返回另一个 Socket。 监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作监听 Socket，一个叫作已连接 Socket。连接建立成功之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。","inLanguage":"en-us","author":"nosky","creator":"nosky","publisher":"nosky","accountablePerson":"nosky","copyrightHolder":"nosky","copyrightYear":"2019","datePublished":"2019-11-22 20:54:52 \x2b0800 \x2b0800","dateModified":"2019-11-22 20:54:52 \x2b0800 \x2b0800","url":"https:\/\/no-sky.github.io\/2019\/socket\/","wordCount":"104","keywords":["Network Protocol","Note"]}</script><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\[','\]']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}},"HTML-CSS":{linebreaks:{automatic:true}},SVG:{linebreaks:{automatic:true}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://no-sky.github.io>Note</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>Blog</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/>About</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://no-sky.github.io>Note</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>Blog</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/>About</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">Socket编程</h1><div class=post-meta>Written by <a itemprop=name href=https://no-sky.github.io rel=author>nosky</a> with ♥
<span class=post-time>on <time datetime=2019-11-22 itemprop=datePublished>November 22, 2019</time></span>
in</div></header><div class=post-content><h1 id=-tcp--udp--socket->基于 TCP 和 UDP 协议的 Socket 编程</h1><p>客户端与服务端在通信之前，双方都要建立一个Socket。
在建立 Socket 的时候，应该设置Socket 函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。Socket 编程进行的是端到端的通信，往往意识不到中间经过多少局域网，多少路由器，因而能够设置的参数，也只能是端到端协议之上网络层和传输层的。在网络层，还记得咱们前面讲过的，TCP 协议是基于数据流的，所以设置为SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM。</p><h2 id=-tcp--socket->基于 TCP 协议的 Socket 程序函数调用过程</h2><p>TCP 的服务端要先监听一个端口，一般是先调用 bind 函数，给这个 Socket 赋予一个 IP 地址和端口。当服务端有了 IP 和端口号，就可以调用 listen 函数进行监听。在 TCP 的状态图里面，有一个 listen 状态，当调用这个函数之后，服务端就进入了这个状态，这个时候客户端就可以发起连接了。</p><p>在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完
毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于
syn_rcvd 的状态。
接下来，服务端调用 accept 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。
在服务端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接的 IP 地址和端
口号，然后开始发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept
就会返回另一个 Socket。
监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作监听
Socket，一个叫作已连接 Socket。连接建立成功之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><p><img src=/posts/networkProtocol-geektime/Socket.assets/image-20191130231428780.png alt=image-20191126110222353></p><h2 id=-udp--socket->基于 UDP 协议的 Socket 程序函数调用过程</h2><p>UDP 是没有连接的，所以不需要三次握手，也就不需要调用 listen
和 connect，但是，UDP 的的交互仍然需要 IP 和端口号，因而也需要 bind。UDP 是没有维护连接状
态的，因而不需要每对连接建立一组 Socket，而是只要有一个 Socket，就能够和多个客户端通信。也
正是因为没有连接状态，每次通信的时候，都调用 sendto 和 recvfrom，都可以传入 IP 地址和端口。
这个图的内容就是基于 UDP 协议的 Socket 程序函数调用过程。</p><p><img src=/posts/networkProtocol-geektime/Socket.assets/image-20191130231454586.png alt=image-20191126110329270></p></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>nosky</span></p><p class=copyright-item><span>Link:</span>
<a href=https://no-sky.github.io/2019/socket/>https://no-sky.github.io/2019/socket/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://no-sky.github.io/tags/network-protocol/>#Network Protocol</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://no-sky.github.io>home</a></span></section></div><div class=post-nav><a href=https://no-sky.github.io/2019/icmp-protocol/ class=prev rel=prev title=ICMP&Ping><i class="iconfont icon-left"></i>&nbsp;ICMP&Ping</a>
<a href=https://no-sky.github.io/2019/http/ class=next rel=next title=HTTP协议>HTTP协议&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2016 - 2020</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://no-sky.github.io>nosky</a> |</span>
<a href=http://www.beian.miit.gov.cn/ target=_blank rel="external nofollow"><img src=/images/beian.png>湘ICP备19027112号</a> |
<span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow">Hugo</a> & <a href=https://github.com/liuzc/leaveit target=_blank rel="external nofollow">LeaveIt</a></span></br><span><a href=https://www.upyun.com/><img style=width:80px;height:30px;background-color:#70847d src=/images/upyun.png alt></a></span></div></footer><link href=//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css rel=stylesheet><script src=/js/vendor_gallery.min.js async></script></div></body></html>