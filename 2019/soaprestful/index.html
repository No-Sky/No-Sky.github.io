<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://no-sky.github.io/images/favicon.ico><meta name=robots content="noodp"><meta name=author content="nosky"><meta name=description content="nosky 的个人学习笔记"><meta name=keywords content="[note 笔记 nosky]"><link rel=prev href=https://no-sky.github.io/2019/cloudnetwork/><link rel=canonical href=https://no-sky.github.io/2019/soaprestful/><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>基于XML的SOAP和基于JSON的RESTful | Note</title><meta name=title content="基于XML的SOAP和基于JSON的RESTful | Note"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/no-sky.github.io"},"articleSection":"posts","name":"基于XML的SOAP和基于JSON的RESTful","headline":"基于XML的SOAP和基于JSON的RESTful","description":"传输协议问题 基于XML的最著名的通信协议就是 SOAP 了，全称 简单对象访问协议 （Simple Object Access Protocol）。它使用XML编写简单的请求和回复消息，并用HTTP协议进行传输。 SOAP将请求和回复放在一个信封里面，就像传递一个邮件一样。信封里面的信分 抬头 和 正文 。\nPOST \/purchaseOrder HTTP\/1.1 Host: www.geektime.com Content-Type: application\/soap\x2bxml; charset=utf-8 Content-Length: nnn \x26lt;?xml version=\x26#34;1.0\x26#34;?\x26gt; \x26lt;soap:Envelope xmlns:soap=\x26#34;http:\/\/www.w3.org\/2001\/12\/soap-envelope\x26#34; soap:encodingStyle=\x26#34;http:\/\/www.w3.org\/2001\/12\/soap-encoding\x26#34;\x26gt; \x26lt;soap:Header\x26gt; \x26lt;m:Trans xmlns:m=\x26#34;http:\/\/www.w3schools.com\/transaction\/\x26#34; soap:mustUnderstand=\x26#34;1\x26#34;\x26gt;1234 \x26lt;\/m:Trans\x26gt; \x26lt;\/soap:Header\x26gt; \x26lt;soap:Body xmlns:m=\x26#34;http:\/\/www.geektime.com\/perchaseOrder\x26#34;\x26gt; \x26lt;m:purchaseOrder\x26#34;\x26gt; \x26lt;order\x26gt; \x26lt;date\x26gt;2018-07-01\x26lt;\/date\x26gt; \x26lt;className\x26gt;趣谈网络协议\x26lt;\/className\x26gt; \x26lt;Author\x26gt;刘超\x26lt;\/Author\x26gt; \x26lt;price\x26gt;68\x26lt;\/price\x26gt; \x26lt;\/order\x26gt; \x26lt;\/m:purchaseOrder\x26gt; \x26lt;\/soap:Body\x26gt; \x26lt;\/soap:Envelope\x26gt; HTTP协议我们学过，这个请求使用POST方法，发送一个格式为 application\/soap \x2b xml 的XML正文给 www.geektime.com，从而下一个单，这个订单封装在SOAP的信封里面，并且表明这 是一笔交易（transaction），而且订单的详情都已经写明了。\n而且XML的格式也可以改成另外一种简单的文本化的对象表示格式JSON。\nPOST \/purchaseOrder HTTP\/1.1 Host: www.geektime.com Content-Type: application\/json; charset=utf-8 Content-Length: nnn { \x26quot;order\x26quot;: { \x26quot;date\x26quot;: \x26quot;2018-07-01\x26quot;, \x26quot;className\x26quot;: \x26quot;趣谈网络协议\x26quot;, \x26quot;Author\x26quot;: \x26quot;刘超\x26quot;, \x26quot;price\x26quot;: \x26quot;68\x26quot; } } 这就是RESTful格式的API的样子。","inLanguage":"en-us","author":"nosky","creator":"nosky","publisher":"nosky","accountablePerson":"nosky","copyrightHolder":"nosky","copyrightYear":"2019","datePublished":"2019-12-04 18:16:36 \x2b0800 \x2b0800","dateModified":"2019-12-04 18:16:36 \x2b0800 \x2b0800","url":"https:\/\/no-sky.github.io\/2019\/soaprestful\/","wordCount":"128","keywords":["Network Protocol","Note"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://no-sky.github.io>Note</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>Blog</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/>About</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://no-sky.github.io>Note</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>Blog</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/>About</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">基于XML的SOAP和基于JSON的RESTful</h1><div class=post-meta>Written by <a itemprop=name href=https://no-sky.github.io rel=author>nosky</a> with ♥
<span class=post-time>on <time datetime=2019-12-04 itemprop=datePublished>December 4, 2019</time></span>
in</div></header><div class=post-content><h1 id=heading>传输协议问题</h1><p>基于XML的最著名的通信协议就是 SOAP 了，全称 简单对象访问协议 （Simple Object Access Protocol）。它使用XML编写简单的请求和回复消息，并用HTTP协议进行传输。
SOAP将请求和回复放在一个信封里面，就像传递一个邮件一样。信封里面的信分 抬头 和 正文 。</p><pre><code>POST /purchaseOrder HTTP/1.1
Host: www.geektime.com
Content-Type: application/soap+xml; charset=utf-8
Content-Length: nnn
</code></pre><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-XML data-lang=XML><span style=color:#75715e>&lt;?xml version=&#34;1.0&#34;?&gt;</span>
<span style=color:#f92672>&lt;soap:Envelope</span> <span style=color:#a6e22e>xmlns:soap=</span><span style=color:#e6db74>&#34;http://www.w3.org/2001/12/soap-envelope&#34;</span>
<span style=color:#a6e22e>soap:encodingStyle=</span><span style=color:#e6db74>&#34;http://www.w3.org/2001/12/soap-encoding&#34;</span><span style=color:#f92672>&gt;</span>
<span style=color:#f92672>&lt;soap:Header</span><span style=color:#f92672>&gt;</span>
<span style=color:#f92672>&lt;m:Trans</span> <span style=color:#a6e22e>xmlns:m=</span><span style=color:#e6db74>&#34;http://www.w3schools.com/transaction/&#34;</span>
<span style=color:#a6e22e>soap:mustUnderstand=</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>&gt;</span>1234
<span style=color:#f92672>&lt;/m:Trans&gt;</span>
<span style=color:#f92672>&lt;/soap:Header&gt;</span>
<span style=color:#f92672>&lt;soap:Body</span> <span style=color:#a6e22e>xmlns:m=</span><span style=color:#e6db74>&#34;http://www.geektime.com/perchaseOrder&#34;</span><span style=color:#f92672>&gt;</span>
<span style=color:#f92672>&lt;m:purchaseOrder</span><span style=color:#960050;background-color:#1e0010>&#34;</span><span style=color:#f92672>&gt;</span>
<span style=color:#f92672>&lt;order</span><span style=color:#f92672>&gt;</span>
<span style=color:#f92672>&lt;date</span><span style=color:#f92672>&gt;</span>2018-07-01<span style=color:#f92672>&lt;/date&gt;</span>
<span style=color:#f92672>&lt;className</span><span style=color:#f92672>&gt;</span>趣谈网络协议<span style=color:#f92672>&lt;/className&gt;</span>
<span style=color:#f92672>&lt;Author</span><span style=color:#f92672>&gt;</span>刘超<span style=color:#f92672>&lt;/Author&gt;</span>
<span style=color:#f92672>&lt;price</span><span style=color:#f92672>&gt;</span>68<span style=color:#f92672>&lt;/price&gt;</span>
<span style=color:#f92672>&lt;/order&gt;</span>
<span style=color:#f92672>&lt;/m:purchaseOrder&gt;</span>
<span style=color:#f92672>&lt;/soap:Body&gt;</span>
<span style=color:#f92672>&lt;/soap:Envelope&gt;</span>
</code></pre></div><p>HTTP协议我们学过，这个请求使用POST方法，发送一个格式为 application/soap + xml 的XML正文给 <a href=http://www.geektime.com>www.geektime.com</a>，从而下一个单，这个订单封装在SOAP的信封里面，并且表明这
是一笔交易（transaction），而且订单的详情都已经写明了。</p><p>而且XML的格式也可以改成另外一种简单的文本化的对象表示格式JSON。</p><pre><code>POST /purchaseOrder HTTP/1.1
Host: www.geektime.com
Content-Type: application/json; charset=utf-8
Content-Length: nnn
{
&quot;order&quot;: {
&quot;date&quot;: &quot;2018-07-01&quot;,
&quot;className&quot;: &quot;趣谈网络协议&quot;,
&quot;Author&quot;: &quot;刘超&quot;,
&quot;price&quot;: &quot;68&quot;
}
}
</code></pre><p>这就是RESTful格式的API的样子。</p><h1 id=heading1>协议约定问题</h1><p>接下来我们解决第二个问题，就是双方的协议约定是什么样的？</p><p>因为服务开发出来是给陌生人用的，就像上面下单的那个XML文件，对于客户端来说，它如何知道应该拼装成上面的格式呢？这就需要对于服务进行描述.因而，我们需要一种相对比较严谨的Web服务描述语言 ， WSDL （Web Service Description Languages）。它也是一个XML文件。在这个文件中，要定义一个类型order，与上面的XML对应起来。</p><p>然而RESTful可不仅仅是指API，而是一种架构风格，全称Representational State Transfer，表述性状态转移，来自一篇重要的论文《架构风格与基于网络的软件架构设计》（Architectural Styles and the Design of Network-based Software Architectures）。</p><p>这篇文章从深层次，更加抽象地论证了一个互联网应用应该有的设计要点，而这些设计要点，成为后来我们能看到的所有高并发应用设计都必须要考虑的问题，再加上REST API比较简单直接，所以后来几乎成为互联网应用的标准接口。</p><p>因此，和SOAP不一样，REST不是一种严格规定的标准，它其实是一种设计风格。如果按这种风格进行设计，RESTful接口和SOAP接口都能做到，只不过后面的架构是REST倡导的，而SOAP相对比较关注前面的接口。
而且由于能够通过WSDL生成客户端的Stub，因而SOAP常常被用于类似传统的RPC方式，也即调用远端和调用本地是一样的。</p><h1 id=heading2>服务发现问题</h1><p>SOAP 对应的有UDDI （Universal Description, Discovery, and Integration），也即 统一描述、发现和集成协议 。它其实是一个注册中心，服务提供方可以将上面的WSDL描述文件，发布到这个注册中心，注册完毕后，服务使用方可以查找到服务的描述，封装为本地的客户端进行调用。</p><p>对于RESTful API来讲，我们已经解决了传输协议的问题——基于HTTP，协议约定问题——基于JSON，最后要解决的是服务发现问题。
有个著名的基于RESTful API的跨系统调用框架叫Spring Cloud。在Spring Cloud中有一个组件叫 Eureka。传说，阿基米德在洗澡时发现浮力原理，高兴得来不及穿上裤子，跑到街上大喊：“Eureka（我找到了）！”所以Eureka是用来实现注册中心的，负责维护注册的服务列表。
服务分服务提供方，它向Eureka做服务注册、续约和下线等操作，注册的主要数据包括服务名、机器IP、端口号、域名等等。
另外一方是服务消费方，向Eureka获取服务提供方的注册信息。为了实现负载均衡和容错，服务提供方可以注册多个。
当消费方要调用服务的时候，会从注册中心读出多个服务来，那怎么调用呢？当然是RESTful方式了。
Spring Cloud提供一个RestTemplate工具，用于将请求对象转换为JSON，并发起Rest调用，RestTemplate的调用也是分POST、PUT、GET、 DELETE的，当结果返回的时候，根据返回的
JSON解析成对象。
通过这样封装，调用起来也很方便。</p></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>nosky</span></p><p class=copyright-item><span>Link:</span>
<a href=https://no-sky.github.io/2019/soaprestful/>https://no-sky.github.io/2019/soaprestful/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://no-sky.github.io/tags/network-protocol/>#Network Protocol</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://no-sky.github.io>home</a></span></section></div><div class=post-nav><a href=https://no-sky.github.io/2019/cloudnetwork/ class=prev rel=prev title=CloudNetwork><i class="iconfont icon-left"></i>&nbsp;CloudNetwork</a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2016 - 2019</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://no-sky.github.io>nosky</a> |</span>
<span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow">Hugo</a> & <a href=https://github.com/liuzc/leaveit target=_blank rel="external nofollow">LeaveIt</a></span></div></footer><script src=/js/vendor_no_gallery.min.js async></script></div></body></html>