<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://no-sky.github.io/images/favicon.ico><meta name=robots content="noodp"><meta name=author content="nosky"><meta name=description content="nosky 的个人学习笔记"><meta name=keywords content="[note 笔记 nosky]"><link rel=prev href=https://no-sky.github.io/2019/sort/><link rel=next href=https://no-sky.github.io/2019/binary-search/><link rel=canonical href=https://no-sky.github.io/2019/hash-algrothm/><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>哈希算法：如何防止数据库中的用户信息被脱库 | Note</title><meta name=title content="哈希算法：如何防止数据库中的用户信息被脱库 | Note"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/no-sky.github.io"},"articleSection":"posts","name":"哈希算法：如何防止数据库中的用户信息被脱库","headline":"哈希算法：如何防止数据库中的用户信息被脱库","description":"哈希算法：如何防止数据库中的用户信息被脱库 什么是哈希算法？ 哈希算法的定义和原理非常简单，基本上一句话就可以概括了。将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。但是，要想设计一个优秀的哈希算法并不容易，根据我的经验，我总结了需要满足的几点要求：\n 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）； 对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也大不相同； 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小； 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。  哈希算法的应用 应用一：安全加密 最常用于加密的哈希算法是MD5（MD5 Message-Digest Algorithm，MD5消息摘要算法）和SHA（Secure Hash Algorithm，安全散列算法）。\n除了这两个之外，当然还有很多其他加密算法，比如DES（Data Encryption Standard，数据加密标准）、AES（Advanced Encryption Standard，高级加密标准）。\n对用于加密的哈希算法来说，有两点格外重要。第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。\n应用二：唯一标识 我们知道，任何文件在计算中都可以表示成二进制码串， 我们可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制码串开头取100个字节，从中间取100个字节，从最后再取100个字节，然后将这300个字节放到一块，通过哈希算法（比如MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。\n应用三：数据校验 我们通过哈希算法，对100个文件块分别取哈希值，并且保存在种子文件中。我们在前面讲过，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。\n应用四：散列函数 实际上，散列函数也是哈希算法的一种应用。\n解答开篇 好了，有了前面的基础，现在你有没有发现开篇的问题其实很好解决？\n我们可以通过哈希算法，对用户密码进行加密之后再存储，不过最好选择相对安全的加密算法，比如SHA等（因为MD5已经号称被破解了）。不过仅仅这样加密之后存储就万事大吉了吗？\n字典攻击你听说过吗？如果用户信息被“脱库”，黑客虽然拿到是加密之后的密文，但可以通过“猜”的方式来破解密码，这是因为，有些用户的密码太简单。比如很多人习惯用00000、123456这样的简单数字组合做密码，很容易就被猜中。\n那我们就需要维护一个常用密码的字典表，把字典中的每个密码用哈希算法计算哈希值，然后拿哈希值跟脱库后的密文比对。如果相同，基本上就可以认为，这个加密之后的密码对应的明文就是字典中的这个密码。（注意，这里说是的是“基本上可以认为”，因为根据我们前面的学习，哈希算法存在散列冲突，也有可能出现，尽管密文一样，但是明文并不一样的情况。）\n针对字典攻击，我们可以引入一个盐（salt），跟用户的密码组合在一起，增加密码的复杂度。我们拿组合之后的字符串来做哈希算法加密，将它存储到数据库中，进一步增加破解的难度。不过我这里想多说一句，我认为安全和攻击是一种博弈关系，不存在绝对的安全。所有的安全措施，只是增加攻击的成本而已。","inLanguage":"en-us","author":"nosky","creator":"nosky","publisher":"nosky","accountablePerson":"nosky","copyrightHolder":"nosky","copyrightYear":"2019","datePublished":"2019-11-20 09:00:52 \x2b0800 \x2b0800","dateModified":"2019-11-20 09:00:52 \x2b0800 \x2b0800","url":"https:\/\/no-sky.github.io\/2019\/hash-algrothm\/","wordCount":"33","keywords":["DataStructure\x26Algorithms","Note"]}</script><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\[','\]']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}},"HTML-CSS":{linebreaks:{automatic:true}},SVG:{linebreaks:{automatic:true}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://no-sky.github.io>Note</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>Blog</a>
<a class=menu-item href=/tags/>Tags</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://no-sky.github.io>Note</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>Blog</a>
<a class=menu-item href=/tags/>Tags</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">哈希算法：如何防止数据库中的用户信息被脱库</h1><div class=post-meta>Written by <a itemprop=name href=https://no-sky.github.io rel=author>nosky</a> with ♥
<span class=post-time>on <time datetime=2019-11-20 itemprop=datePublished>November 20, 2019</time></span>
in</div></header><div class=post-content><h1 id=heading>哈希算法：如何防止数据库中的用户信息被脱库</h1><h2 id=heading1>什么是哈希算法？</h2><p>哈希算法的定义和原理非常简单，基本上一句话就可以概括了。将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是<strong>哈希算法</strong>，而通过原始数据映射之后得到的二进制值串就是<strong>哈希值</strong>。但是，要想设计一个优秀的哈希算法并不容易，根据我的经验，我总结了需要满足的几点要求：</p><ul><li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</li><li>对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也大不相同；</li><li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li><li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li></ul><h2 id=heading2>哈希算法的应用</h2><h3 id=heading3>应用一：安全加密</h3><p>最常用于加密的哈希算法是<strong>MD5</strong>（MD5 Message-Digest Algorithm，MD5消息摘要算法）和<strong>SHA</strong>（Secure Hash Algorithm，安全散列算法）。</p><p>除了这两个之外，当然还有很多其他加密算法，比如<strong>DES</strong>（Data Encryption Standard，数据加密标准）、<strong>AES</strong>（Advanced Encryption Standard，高级加密标准）。</p><p>对用于加密的哈希算法来说，有两点格外重要。第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。</p><h3 id=heading4>应用二：唯一标识</h3><p>我们知道，任何文件在计算中都可以表示成二进制码串， 我们可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制码串开头取100个字节，从中间取100个字节，从最后再取100个字节，然后将这300个字节放到一块，通过哈希算法（比如MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。</p><h3 id=heading5>应用三：数据校验</h3><p>我们通过哈希算法，对100个文件块分别取哈希值，并且保存在种子文件中。我们在前面讲过，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p><h3 id=heading6>应用四：散列函数</h3><p>实际上，散列函数也是哈希算法的一种应用。</p><h2 id=heading7>解答开篇</h2><p>好了，有了前面的基础，现在你有没有发现开篇的问题其实很好解决？</p><p>我们可以通过哈希算法，对用户密码进行加密之后再存储，不过最好选择相对安全的加密算法，比如SHA等（因为MD5已经号称被破解了）。不过仅仅这样加密之后存储就万事大吉了吗？</p><p>字典攻击你听说过吗？如果用户信息被“脱库”，黑客虽然拿到是加密之后的密文，但可以通过“猜”的方式来破解密码，这是因为，有些用户的密码太简单。比如很多人习惯用00000、123456这样的简单数字组合做密码，很容易就被猜中。</p><p>那我们就需要维护一个常用密码的字典表，把字典中的每个密码用哈希算法计算哈希值，然后拿哈希值跟脱库后的密文比对。如果相同，基本上就可以认为，这个加密之后的密码对应的明文就是字典中的这个密码。（注意，这里说是的是“基本上可以认为”，因为根据我们前面的学习，哈希算法存在散列冲突，也有可能出现，尽管密文一样，但是明文并不一样的情况。）</p><p>针对字典攻击，我们可以引入一个盐（salt），跟用户的密码组合在一起，增加密码的复杂度。我们拿组合之后的字符串来做哈希算法加密，将它存储到数据库中，进一步增加破解的难度。不过我这里想多说一句，我认为安全和攻击是一种博弈关系，不存在绝对的安全。所有的安全措施，只是增加攻击的成本而已。</p></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>nosky</span></p><p class=copyright-item><span>Link:</span>
<a href=https://no-sky.github.io/2019/hash-algrothm/>https://no-sky.github.io/2019/hash-algrothm/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://no-sky.github.io/tags/datastructurealgorithms/>#DataStructure&Algorithms</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://no-sky.github.io>home</a></span></section></div><div class=post-nav><a href=https://no-sky.github.io/2019/sort/ class=prev rel=prev title=排序><i class="iconfont icon-left"></i>&nbsp;排序</a>
<a href=https://no-sky.github.io/2019/binary-search/ class=next rel=next title=二分查找（上）：如何用最省内存的方式实现快速查找功能>二分查找（上）：如何用最省内存的方式实现快速查找功能&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2016 - 2020</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://no-sky.github.io>nosky</a> |</span>
<a href=http://beian.miit.gov.cn/ target=_blank rel="external nofollow">湘ICP备19027112号</a> |
<span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow">Hugo</a> & <a href=https://github.com/liuzc/leaveit target=_blank rel="external nofollow">LeaveIt</a></span></br><span><a href=https://www.upyun.com/><img style=width:80px;height:30px;background-color:#70847d src=/images/upyun.png alt></a></span></div></footer><script src=/js/vendor_no_gallery.min.js async></script></div></body></html>