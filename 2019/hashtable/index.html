<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://no-sky.github.io/images/favicon.ico><meta name=robots content="noodp"><meta name=author content="nosky"><meta name=description content="nosky 的个人学习笔记"><meta name=keywords content="[note 笔记 nosky]"><link rel=prev href=https://no-sky.github.io/2019/skip-list/><link rel=next href=https://no-sky.github.io/2019/sort-optimization/><link rel=canonical href=https://no-sky.github.io/2019/hashtable/><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>散列表：Word文档中的单词拼写检查功能是如何实现的 | Note</title><meta name=title content="散列表：Word文档中的单词拼写检查功能是如何实现的 | Note"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/no-sky.github.io"},"articleSection":"posts","name":"散列表：Word文档中的单词拼写检查功能是如何实现的","headline":"散列表：Word文档中的单词拼写检查功能是如何实现的","description":"散列表：Word文档中的单词拼写检查功能是如何实现的 散列思想 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。\n散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是O(1)的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。\n散列函数 散列函数，顾名思义，它是一个函数。我们可以把它定义成hash(key)，其中key表示元素的键值，hash(key)的值表示经过散列函数计算得到的散列值。\n该如何构造散列函数呢？我总结了三点散列函数设计的基本要求：\n 散列函数计算得到的散列值是一个非负整数； 如果key1 = key2，那hash(key1) == hash(key2)； 如果key1 ≠ key2，那hash(key1) ≠ hash(key2)。  我们几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，我们需要通过其他途径来解决。\n解答开篇 有了前面这些基本知识储备，我们来看一下开篇的思考题：Word文档中单词拼写检查功能是如何实现的？\n常用的英文单词有20万个左右，假设单词的平均长度是10个字母，平均一个单词占用10个字节的内存空间，那20万英文单词大约占2MB的存储空间，就算放大10倍也就是20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。\n当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。","inLanguage":"en-us","author":"nosky","creator":"nosky","publisher":"nosky","accountablePerson":"nosky","copyrightHolder":"nosky","copyrightYear":"2019","datePublished":"2019-11-20 09:00:52 \x2b0800 \x2b0800","dateModified":"2019-11-20 09:00:52 \x2b0800 \x2b0800","url":"https:\/\/no-sky.github.io\/2019\/hashtable\/","wordCount":"23","keywords":["DataStructure\x26Algorithms","Note"]}</script><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\[','\]']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}},"HTML-CSS":{linebreaks:{automatic:true}},SVG:{linebreaks:{automatic:true}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://no-sky.github.io>Note</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>Blog</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/>About</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://no-sky.github.io>Note</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>Blog</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/>About</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">散列表：Word文档中的单词拼写检查功能是如何实现的</h1><div class=post-meta>Written by <a itemprop=name href=https://no-sky.github.io rel=author>nosky</a> with ♥
<span class=post-time>on <time datetime=2019-11-20 itemprop=datePublished>November 20, 2019</time></span>
in</div></header><div class=post-content><h1 id=word>散列表：Word文档中的单词拼写检查功能是如何实现的</h1><h2 id=heading>散列思想</h2><p><strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong></p><p>散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是O(1)的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p><h2 id=heading1>散列函数</h2><p>散列函数，顾名思义，它是一个函数。我们可以把它定义成<strong>hash(key)</strong>，其中key表示元素的键值，hash(key)的值表示经过散列函数计算得到的散列值。</p><p><strong>该如何构造散列函数呢？我总结了三点散列函数设计的基本要求</strong>：</p><ol><li>散列函数计算得到的散列值是一个非负整数；</li><li>如果key1 = key2，那hash(key1) == hash(key2)；</li><li>如果key1 ≠ key2，那hash(key1) ≠ hash(key2)。</li></ol><p>我们几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，我们需要通过其他途径来解决。</p><h2 id=heading2>解答开篇</h2><p>有了前面这些基本知识储备，我们来看一下开篇的思考题：Word文档中单词拼写检查功能是如何实现的？</p><p>常用的英文单词有20万个左右，假设单词的平均长度是10个字母，平均一个单词占用10个字节的内存空间，那20万英文单词大约占2MB的存储空间，就算放大10倍也就是20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。</p><p>当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</p></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>nosky</span></p><p class=copyright-item><span>Link:</span>
<a href=https://no-sky.github.io/2019/hashtable/>https://no-sky.github.io/2019/hashtable/</span></p><p class="copyright-item lincese">本文采用<a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/ target=_blank>知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://no-sky.github.io/tags/datastructurealgorithms/>#DataStructure&Algorithms</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://no-sky.github.io>home</a></span></section></div><div class=post-nav><a href=https://no-sky.github.io/2019/skip-list/ class=prev rel=prev title=跳表><i class="iconfont icon-left"></i>&nbsp;跳表</a>
<a href=https://no-sky.github.io/2019/sort-optimization/ class=next rel=next title=排序优化：如何实现一个通用的、高性能的排序函数>排序优化：如何实现一个通用的、高性能的排序函数&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2016 - 2019</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://no-sky.github.io>nosky</a> |</span>
<a href=http://www.beian.miit.gov.cn/ target=_blank rel="external nofollow">湘ICP备19027112号</a> |
<span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow">Hugo</a> & <a href=https://github.com/liuzc/leaveit target=_blank rel="external nofollow">LeaveIt</a></span></br><span><a href=https://www.upyun.com/><img style=width:80px;height:30px;background-color:#70847d src=/images/upyun.png alt></a></span></div></footer><script src=/js/vendor_no_gallery.min.js async></script></div></body></html>