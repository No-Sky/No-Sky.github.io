<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Note</title><link>https://no-sky.github.io/posts/</link><description>Recent content in Posts on Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 04 Dec 2019 18:16:36 +0800</lastBuildDate><atom:link href="https://no-sky.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>基于XML的SOAP和基于JSON的RESTful</title><link>https://no-sky.github.io/2019/soaprestful/</link><pubDate>Wed, 04 Dec 2019 18:16:36 +0800</pubDate><guid>https://no-sky.github.io/2019/soaprestful/</guid><description>传输协议问题 基于XML的最著名的通信协议就是 SOAP 了，全称 简单对象访问协议 （Simple Object Access Protocol）。它使用XML编写简单的请求和回复消息，并用HTTP协议进行传输。 SOAP将请求和回复放在一个信封里面，就像传递一个邮件一样。信封里面的信分 抬头 和 正文 。
POST /purchaseOrder HTTP/1.1 Host: www.geektime.com Content-Type: application/soap+xml; charset=utf-8 Content-Length: nnn &amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;soap:Envelope xmlns:soap=&amp;#34;http://www.w3.org/2001/12/soap-envelope&amp;#34; soap:encodingStyle=&amp;#34;http://www.w3.org/2001/12/soap-encoding&amp;#34;&amp;gt; &amp;lt;soap:Header&amp;gt; &amp;lt;m:Trans xmlns:m=&amp;#34;http://www.w3schools.com/transaction/&amp;#34; soap:mustUnderstand=&amp;#34;1&amp;#34;&amp;gt;1234 &amp;lt;/m:Trans&amp;gt; &amp;lt;/soap:Header&amp;gt; &amp;lt;soap:Body xmlns:m=&amp;#34;http://www.geektime.com/perchaseOrder&amp;#34;&amp;gt; &amp;lt;m:purchaseOrder&amp;gt; &amp;lt;order&amp;gt; &amp;lt;date&amp;gt;2018-07-01&amp;lt;/date&amp;gt; &amp;lt;className&amp;gt;趣谈网络协议&amp;lt;/className&amp;gt; &amp;lt;Author&amp;gt;刘超&amp;lt;/Author&amp;gt; &amp;lt;price&amp;gt;68&amp;lt;/price&amp;gt; &amp;lt;/order&amp;gt; &amp;lt;/m:purchaseOrder&amp;gt; &amp;lt;/soap:Body&amp;gt; &amp;lt;/soap:Envelope&amp;gt; HTTP协议我们学过，这个请求使用POST方法，发送一个格式为 application/soap + xml 的XML正文给 www.geektime.com，从而下一个单，这个订单封装在SOAP的信封里面，并且表明这 是一笔交易（transaction），而且订单的详情都已经写明了。
而且XML的格式也可以改成另外一种简单的文本化的对象表示格式JSON。
POST /purchaseOrder HTTP/1.1 Host: www.geektime.com Content-Type: application/json; charset=utf-8 Content-Length: nnn { &amp;#34;order&amp;#34;: { &amp;#34;date&amp;#34;: &amp;#34;2018-07-01&amp;#34;, &amp;#34;className&amp;#34;: &amp;#34;趣谈网络协议&amp;#34;, &amp;#34;Author&amp;#34;: &amp;#34;刘超&amp;#34;, &amp;#34;price&amp;#34;: &amp;#34;68&amp;#34; } } 这就是RESTful格式的API的样子。</description></item><item><title>CloudNetwork</title><link>https://no-sky.github.io/2019/cloudnetwork/</link><pubDate>Wed, 04 Dec 2019 18:08:05 +0800</pubDate><guid>https://no-sky.github.io/2019/cloudnetwork/</guid><description>自建机房的缺点 采购不灵活：如果客户需要一台电脑，那就需要自己采购、上架、插网线、安装操作系统，周期非常长。一旦采购了，一用就N年，不能退货，哪怕业务不做了，机器还在数据中心里留着。
运维不灵活：一旦需要扩容CPU、内存、硬盘，都需要去机房手动弄，非常麻烦。
规格不灵活：采购的机器往往动不动几百G的内存，而每个应用往往可能只需要4核8G，所以很多应用混合部署在上面，端口各种冲突，容易相互影响。
复用不灵活：一台机器，一旦一个用户不用了，给另外一个用户，那就需要重装操作系统。因为原来的操作系统可能遗留很多数据，非常麻烦。
从物理机到虚拟机 为了解决这些问题，人们发明了一种叫虚拟机的东西，并基于它产生了云计算技术。
虚拟网卡连接到云中 我们就这样有了虚拟TAP网卡。接下来就要看，这个卡怎么接入庞大的数据中心网络中。 在接入之前，我们先来看，云计算中的网络都需要注意哪些点。
共享 ：尽管每个虚拟机都会有一个或者多个虚拟网卡，但是物理机上可能只有有限的网卡。那这么多虚拟网卡如何共享同一个出口？
隔离 ：分两个方面，一个是安全隔离，两个虚拟机可能属于两个用户，那怎么保证一个用户的数据不被另一个用户窃听？一个是流量隔离，两个虚拟机，如果有一个疯狂下片，会不会导致另外一个上不了网？
互通 ：分两个方面，一个是如果同一台机器上的两个虚拟机，属于同一个用户的话，这两个如何相互通信？另一个是如果不同物理机上的两个虚拟机，属于同一个用户的话，这两个如何相互通信？
灵活 ：虚拟机和物理不同，会经常创建、删除，从一个机器漂移到另一台机器，有的互通、有的不通等等，灵活性比物理网络要好得多，需要能够灵活配置。
共享与互通问题 桥接 NAT 隔离问题 如果一台机器上的两个虚拟机不属于同一个用户，怎么办呢？好在brctl创建的网桥也是支持VLAN功能的，可以设置两个虚拟机的tag，这样在这个虚拟网桥上，两个虚拟机是不互通的。 但是如何跨物理机互通，并且实现VLAN的隔离呢？由于brctl创建的网桥上面的tag是没办法在网桥之外的范围内起作用的，于是我们需要寻找其他的方式。 有一个命令 vconfig ，可以基于物理网卡eth0创建带VLAN的虚拟网卡，所有从这个虚拟网卡出去的包，都带这个VLAN，如果这样，跨物理机的互通和隔离就可以通过这个网卡来实现。 首先为每个用户分配不同的VLAN，例如有一个用户VLAN 10，一个用户VLAN 20。在一台物理机上，基于物理网卡，为每个用户用vconfig创建一个带VLAN的网卡。不同的用户使用不同的虚 拟网桥，带VLAN的虚拟网卡也连接到虚拟网桥上。</description></item><item><title>移动网络</title><link>https://no-sky.github.io/2019/mobilenetwork/</link><pubDate>Wed, 04 Dec 2019 17:56:06 +0800</pubDate><guid>https://no-sky.github.io/2019/mobilenetwork/</guid><description>移动网络的发展历程 你一定知道手机上网有2G、3G、4G的说法，究竟这都是什么意思呢？有一个通俗的说法就是：用2G看txt，用3G看jpg，用4G看avi。
2G网络 手机本来是用来打电话的，不是用来上网的，所以原来在2G时代，上网使用的不是IP网络，而是电话网络，走模拟信号，专业名称为公共交换电话网（PSTN，Public Switched Telephone Network）。 那手机不连网线，也不连电话线，它是怎么上网的呢？ 手机是通过收发无线信号来通信的，专业名称是Mobile Station，简称MS，需要嵌入SIM。手机是客户端，而无线信号的服务端，就是基站子系统（BSS，Base Station SubsystemBSS）。至 于什么是基站，你可以回想一下，你在爬山的时候，是不是看到过信号塔？我们平时城市里面的基站比较隐蔽，不容易看到，所以只有在山里才会注意到。正是这个信号塔，通过无线信号，让你 的手机可以进行通信。
2.5G网络 后来从2G到了2.5G，也即在原来电路交换的基础上，加入了分组交换业务，支持Packet的转发，从而支持IP网络。 在上述网络的基础上，基站一面朝前接无线，一面朝后接核心网。在朝后的组件中，多了一个分组控制单元（PCU，Packet Control Unit），用以提供分组交换通道。 在核心网里面，有个朝前的接待员（SGSN，Service GPRS Supported Node）和朝后连接IP网络的网关型GPRS支持节点（GGSN，Gateway GPRS Supported Node）。
3G网络 到了3G时代，主要是无线通信技术有了改进，大大增加了无线的带宽。 以W-CDMA为例，理论最高2M的下行速度，因而基站改变了，一面朝外的是Node B，一面朝内连接核心网的是无线网络控制器（RNC，Radio Network Controller）。核心网以及连接的IP网 络没有什么变化。
4G网络 然后就到了今天的4G网络，基站为eNodeB，包含了原来Node B和RNC的功能，下行速度向百兆级别迈进。另外，核心网实现了控制面和数据面的分离，这个怎么理解呢？ 在前面的核心网里面，有接待员MSC或者SGSN，你会发现检查是否合法是它负责，转发数据也是它负责，也即控制面和数据面是合二为一的，这样灵活性比较差，因为控制面主要是指令，多是 小包，往往需要高的及时性；数据面主要是流量，多是大包，往往需要吞吐量。
4G网络协议解析 手机上网流程 手机开机以后，在附近寻找基站eNodeB，找到后给eNodeB发送Attach Request，说“我来啦，我要上网”。
eNodeB将请求发给MME，说“有个手机要上网”。
MME去请求手机，一是认证，二是鉴权，还会请求HSS看看有没有钱，看看是在哪里上网。
当MME通过了手机的认证之后，开始分配隧道，先告诉SGW，说要创建一个会话（Create Session）。在这里面，会给SGW分配一个隧道ID t1，并且请求SGW给自己也分配一个隧道ID。
SGW转头向PGW请求建立一个会话，为PGW的控制面分配一个隧道ID t2，也给PGW的数据面分配一个隧道ID t3，并且请求PGW给自己的控制面和数据面分配隧道ID。
PGW回复SGW说“创建会话成功”，使用自己的控制面隧道ID t2，回复里面携带着给SGW控制面分配的隧道ID t4和控制面的隧道ID t5，至此SGW和PGW直接的隧道建设完成。双方请求 对方，都要带着对方给自己分配的隧道ID，从而标志是这个手机的请求。
接下来SGW回复MME说“创建会话成功”，使用自己的隧道ID t1访问MME，回复里面有给MME分配隧道ID t6，也有SGW给eNodeB分配的隧道ID t7。</description></item><item><title>VPN</title><link>https://no-sky.github.io/2019/vpn/</link><pubDate>Wed, 04 Dec 2019 17:39:04 +0800</pubDate><guid>https://no-sky.github.io/2019/vpn/</guid><description>连接多个数据中心的方式： 走公网，最简单但不安全 专线连接，成本高昂，效率高 VPN 连接，简单便宜，保证私密性，性能稍差 VPN ，全名 Virtual Private Network ， 虚拟专用网 ，就是利用开放的公众网络，建立专用数据传输通道，将远程的分支机构、移动办公人员等连接起来。
VPN是如何工作的？ VPN通过隧道技术在公众网络上仿真一条点到点的专线，是通过利用一种协议来传输另外一种协议的技术，这里面涉及三种协议： 乘客协议 、 隧道协议 和 承载协议 。 我们以IPsec协议为例来说明。
IPSec VPN「Virtual Private Network」工作原理： 将要发送的 IP 包「乘客协议」加密后加上 IPSec 包头「隧道协议」后再放入另一个 IP 包「承载协议」中发送 IPSec VPN 是基于 IP 协议的安全隧道协议，采用一些机制保证安全性
私密性：加密数据
完整性：对数据进行 hash 运算产生数据摘要
真实性：通过身份认证保证对端身份的真实性
IPSec VPN 协议簇包括： 两种协议：
AH「Authentication Header」：只能进行数据摘要，不能实现数据加密
ESP「Encapsulating Security Payload」：能够进行数据加密和数据摘要</description></item><item><title>CDN</title><link>https://no-sky.github.io/2019/cdn/</link><pubDate>Tue, 26 Nov 2019 22:54:52 +0800</pubDate><guid>https://no-sky.github.io/2019/cdn/</guid><description>网站的一般访问模式。 当一个用户想访问一个网站的时候，指定这个网站的域名，DNS 就会将这个域名解析为地址，然后用户 请求这个地址，返回一个网页。 那这里面还有没有可以优化的地方呢？ 我们先说，我们的网站访问可以借鉴“就近配送”这个思路。 全球有这么多的数据中心，无论在哪里上网，临近不远的地方基本上都有数据中心。是不是可以在这些 数据中心里部署几台机器，形成一个缓存的集群来缓存部分数据，那么用户访问数据的时候，就可以就 近访问了呢？ 这些分布在各个地方的各个数据中心的节点，就称为边缘节点。 由于边缘节点数目比较多，但是每个集群规模比较小，不可能缓存下来所有东西，因而可能无法命中， 这样就会在边缘节点之上。有区域节点，规模就要更大，缓存的数据会更多，命中的概率也就更大。在 区域节点之上是中心节点，规模更大，缓存数据更多。如果还不命中，就只好回源网站访问了。
这就是CDN 的分发系统的架构。CDN 系统的缓存，也是一层一层的，能不访问后端真正的源，就不打 扰它。
接下来就是，客户端如何找到相应的边缘节点进行访问呢？
CDN 的全局负载均衡器解析域名，全局负载均衡器会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：
根据用户 IP 地址，判断哪一台服务器距用户最近； 用户所处的运营商； 根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需的内容； 查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。 基于以上这些条件，进行综合分析之后，全局负载均衡器会返回一台缓存服务器的 IP 地址。</description></item><item><title>HTTPDNS协议</title><link>https://no-sky.github.io/2019/httpdns/</link><pubDate>Tue, 26 Nov 2019 14:54:52 +0800</pubDate><guid>https://no-sky.github.io/2019/httpdns/</guid><description>传统 DNS 存在哪些问题？ 域名缓存问题 它可以在本地做一个缓存，也就是说，不是每一个请求，它都会去访问权威 DNS 服务器，而是访问过一 次就把结果缓存到自己本地，当其他人来问的时候，直接就返回这个缓存数据。
域名转发问题 缓存问题还是说本地域名解析服务，还是会去权威 DNS 服务器中查找，只不过不是每次都要查找。但是 A 运营商偷懒，将解析的请求转发给 B 运营商，B 运营商去权威 DNS 服务器查询的话，权威服务 器会误认为，你是 B 运营商的，那就返回给你一个在 B 运营商的网站地址吧，结果客户的每次访问都要 跨运营商，速度就会很慢。
出口 NAT 问题 出口的时候，很多机房都会配置NAT，也即网络地址转换，使得从这个网关出去的包，都换成新的 IP 地址，当然请求返回的时候，在这个网关，再将 IP 地址转换回去，所以对于访问来说是没有任何问题。但是一旦做了网络地址的转换，权威的 DNS 服务器，就没办法通过这个地址，来判断客户到底是来自哪个运营商，而且极有可能因为转换过后的地址，误判运营商，导致跨运营商的访问。
域名更新问题 本地 DNS 服务器是由不同地区、不同运营商独立部署的。对域名解析缓存的处理上，实现策略也有区 别，有的会偷懒，忽略域名解析结果的 TTL 时间限制，在权威 DNS 服务器解析变更的时候，解析结果 在全网生效的周期非常漫长。但是有的时候，在 DNS 的切换中，场景对生效时间要求比较高。
解析延迟问题 从上一节的 DNS 查询过程来看，DNS 的查询过程需要递归遍历多个 DNS 服务器，才能获得最终的解 析结果，这会带来一定的时延，甚至会解析超时。
HTTPDNS 的工作模式 HTTPNDS 其实就是，不走传统的 DNS 解析，而是自己搭建基于 HTTP 协议的 DNS 服务器集群，分布 在多个地点和多个运营商。当客户端需要 DNS 解析的时候，直接通过 HTTP 协议进行请求这个服务器 集群，得到就近的地址。</description></item><item><title>DNS协议</title><link>https://no-sky.github.io/2019/dns/</link><pubDate>Tue, 26 Nov 2019 12:54:52 +0800</pubDate><guid>https://no-sky.github.io/2019/dns/</guid><description>DNS 服务器 在网络世界，你需要记得住网站的名称，但是很难记住网站的 IP 地址，因而需要一个地 址簿，就是DNS 服务器。
由此可见，DNS 在日常生活中多么重要。每个人上网，都需要访问它，但是同时，这对它来讲也是非常 大的挑战。一旦它出了故障，整个互联网都将瘫痪。另外，上网的人分布在全世界各地，如果大家都去 同一个地方访问某一台服务器，时延将会非常大。因而，DNS 服务器，一定要设置成高可用、高并发和 分布式的。 于是，就有了这样树状的层次结构。
根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址 顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址 权威 DNS 服务器 ：返回相应主机的 IP 地址 DNS 解析流程 电脑客户端会发出一个 DNS 请求，，并发给本地域名服务器 (本地DNS)。那本地域名服务器 (本地 DNS) 是什么呢？如果是通过 DHCP 配置，本地 DNS 由你的网络服务商（ISP），如电信、移动等自动分配，它通常就在你网络服务商的某个机房。
本地 DNS 收到来自客户端的请求。你可以想象这台服务器上缓存了一张域名与之对应 IP 地址的大 表格。如果能找到请求域名，它直接就返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器。根域名服务器是最高层次的，全球共有 13 套。它不直接用于域名解析，但能指明一条道路。
根 DNS 收到来自本地 DNS 的请求，根据域名后缀转发给对应的顶级域名服务器。</description></item><item><title>P2P协议</title><link>https://no-sky.github.io/2019/p2p/</link><pubDate>Tue, 26 Nov 2019 10:54:52 +0800</pubDate><guid>https://no-sky.github.io/2019/p2p/</guid><description>P2P 是什么？ 无论是 HTTP 的方式，还是 FTP 的方式，都有一个比较大的缺点，就是难以解决单一服务器的带宽 压力， 因为它们使用的都是传统的客户端服务器的方式。 后来，一种创新的、称为 P2P 的方式流行起来。P2P就是peer-to-peer。资源开始并不集中地存储在某 些设备上，而是分散地存储在多台设备上。这些设备我们姑且称为 peer。 想要下载一个文件的时候，你只要得到那些已经存在了文件的 peer，并和这些 peer 之间，建立点对点 的连接，而不需要到中心服务器上。
种子（.torrent）文件 当你想下载一个文件的时候，怎么知道哪些 peer 有这个文件呢？ 这就用到种子啦，也即咱们比较熟悉的.torrent 文件。.torrent 文件由两部分组成，分别是： announce（tracker URL）和文件信息。 文件信息里面有这些内容。 info 区：这里指定的是该种子有几个文件、文件有多长、目录结构，以及目录和文件的名字。 Name 字段：指定顶层目录名字。 每个段的大小：BitTorrent（简称 BT）协议把一个文件分成很多个小段，然后分段下载。 段哈希值：将整个种子中，每个段的 SHA-1 哈希值拼在一起。 P2P 网络需要借助 tracker 中心服务器，这个服务器是用来登记有哪些用户在请求哪些 资源。 所以，这种工作方式有一个弊端，一旦 tracker 服务器出现故障或者线路遭到屏蔽，BT 工具就无法正常 工作了。
去中心化网络（DHT） 后来就有了一种叫作DHT（Distributed Hash Table）的去中心化网络。每个加入这个 DHT 网络 的人，都要负责存储这个网络里的资源信息和其他成员的联系信息，相当于所有人一起构成了一个庞大 的分布式存储数据库。</description></item><item><title>HTTPS协议</title><link>https://no-sky.github.io/2019/https/</link><pubDate>Mon, 25 Nov 2019 10:54:52 +0800</pubDate><guid>https://no-sky.github.io/2019/https/</guid><description>HTTP协议与HTTPS协议的不同在于HTTPS协议对数据进行了加密处理。常用的加密方法有对称加密，非对称加密。
在对称加密算法中，加密和解密使用的密钥是相同的。也就是说，加密和解密使用的是同一个密钥。因 此，对称加密算法要保证安全性的话，密钥要做好保密。只能让使用的人知道，不能对外公开。 在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。一把是作为公开的公钥，另一把 是作为谁都不能给的私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解 密。 因为对称加密算法相比非对称加密算法来说，效率要高得多，性能也好，所以交互的场景下多用对称加 密。
数字证书
不对称加密也会有同样的问题，如何将不对称加密的公钥给对方呢？一种是放在一个公网的地址上，让 对方下载；另一种就是在建立连接的时候，传给对方。 这两种方法有相同的问题，那就是，作为一个普通网民，你怎么鉴别别人给你的公钥是对的。会不会有 人冒充外卖网站，发给你一个它的公钥。接下来，你和它所有的互通，看起来都是没有任何问题的。毕 竟每个人都可以创建自己的公钥和私钥。
这个时候就需要权威部门的介入了这个由权威部门颁发的称为证书（Certificate）。这个权威机构我们称为 CA（ Certifcate Authority）。
HTTPS 的工作模式 我们可以知道，非对称加密在性能上不如对称加密，那是否能将两者结合起来呢？例如，公钥私钥主要 用于传输对称加密的秘钥，而真正的双方大数据量的通信都是通过对称加密进行的。 当然是可以的。这就是 HTTPS 协议的总体思路。</description></item><item><title>HTTP协议</title><link>https://no-sky.github.io/2019/http/</link><pubDate>Sun, 24 Nov 2019 10:54:52 +0800</pubDate><guid>https://no-sky.github.io/2019/http/</guid><description>HTTP请求的准备 HTTP 协议，几乎是每个人上网用的第一个协议，同时也是很容易被人忽略的协议。 既然说看新闻，咱们就先登录 http://www.163.com 。 http://www.163.com 是个 URL，叫作统一资源定位符。之所以叫统一，是因为它是有格式的。HTTP 称为协议，www.163.com 是一个域名，表示互联网上的一个位置。有的 URL 会有更详细的位置标识， 例如 http://www.163.com/index.html 。正是因为这个东西是统一的，所以当你把这样一个字符串输 入到浏览器的框里的时候，浏览器才知道如何进行统一处理。
浏览器会将 www.163.com 这个域名发送给 DNS 服务器，让它解析为 IP 地址。
目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样建立的 TCP 连接，就可以在多次请求中复用。
HTTP 请求的构建 建立了连接以后，浏览器就要发送 HTTP 的请求。 请求的格式就像这样。
HTTP 的报文大概分为三大部分。第一部分是请求行，第二部分是请求的首部，第三部分才是请求的正 文实体。 第一部分：请求行 在请求行中，URL 就是 http://www.163.com ，版本为 HTTP 1.1。这里要说一下的，就是方法。方法 有几种类型。 对于访问网页来讲，最常用的类型就是GET。顾名思义，GET 就是去服务器获取一些资源。对于访问网 页来讲，要获取的资源往往是一个页面。其实也有很多其他的格式，比如说返回一个 JSON 字符串，到 底要返回什么，是由服务器端的实现决定的。 另外一种类型叫做POST。它需要主动告诉服务端一些信息，而非获取。要告诉服务端什么呢？一般会放 在正文里面。正文可以有各种各样的格式。常见的格式也是 JSON。
还有一种类型叫PUT，就是向指定资源位置上传最新内容。但是，HTTP 的服务器往往是不允许上传文件 的，所以 PUT 和 POST 就都变成了要传给服务器东西的方法。
在实际使用过程中，这两者还会有稍许的区别。POST 往往是用来创建一个资源的，而 PUT 往往是用来 修改一个资源的</description></item><item><title>Socket编程</title><link>https://no-sky.github.io/2019/socket/</link><pubDate>Fri, 22 Nov 2019 20:54:52 +0800</pubDate><guid>https://no-sky.github.io/2019/socket/</guid><description>基于 TCP 和 UDP 协议的 Socket 编程 客户端与服务端在通信之前，双方都要建立一个Socket。 在建立 Socket 的时候，应该设置Socket 函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。Socket 编程进行的是端到端的通信，往往意识不到中间经过多少局域网，多少路由器，因而能够设置的参数，也只能是端到端协议之上网络层和传输层的。在网络层，还记得咱们前面讲过的，TCP 协议是基于数据流的，所以设置为SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM。
基于 TCP 协议的 Socket 程序函数调用过程 TCP 的服务端要先监听一个端口，一般是先调用 bind 函数，给这个 Socket 赋予一个 IP 地址和端口。当服务端有了 IP 和端口号，就可以调用 listen 函数进行监听。在 TCP 的状态图里面，有一个 listen 状态，当调用这个函数之后，服务端就进入了这个状态，这个时候客户端就可以发起连接了。
在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完 毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态。 接下来，服务端调用 accept 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。 在服务端等待的时候，客户端可以通过 connect 函数发起连接。先在参数中指明要连接的 IP 地址和端 口号，然后开始发起三次握手。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的 accept 就会返回另一个 Socket。 监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作监听 Socket，一个叫作已连接 Socket。连接建立成功之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</description></item><item><title>ICMP&amp;Ping</title><link>https://no-sky.github.io/2019/icmp-protocol/</link><pubDate>Fri, 22 Nov 2019 16:40:52 +0800</pubDate><guid>https://no-sky.github.io/2019/icmp-protocol/</guid><description>ICMP协议的格式 ping 是基于 ICMP 协议工作的。ICMP全称Internet Control Message Protocol，就是互联网控制报文 协议。 ICMP 报文是封装在 IP 包里面的。因为传输指令的时候，肯定需要源地址和目标地址。它本身非常简 单。ICMP 报文有很多的类型，不同的类型有不同的代码。最常用的类型是主动请求为 8，主动请求的应答为 0。
查询报文类型 常用的ping 就是查询报文，是一种主动请求，并且获得主动应答的 ICMP 协议。所以，ping 发的包也是符合 ICMP 协议格式的，只不过它在后面增加了自己的格式。对 ping 的主动请求，进行网络抓包，称为ICMP ECHO REQUEST。同理主动请求的回复，称为ICMPECHO REPLY。比起原生的 ICMP，这里面多了两个字段，一个是标识符。在选项数据中，ping 还会存放发送请求的时间值，来计算往返时间，说明路程的长短。
差错报文类型 几个 ICMP 差错报文的例子：终点不可达为 3，源抑制为 4，超时为 11，重定向为 5。 第一种是终点不可达。具体的原因在代码中表示就是，网络不可达代码为 0，主机 不可达代码为 1，协议不可达代码为 2，端口不可达代码为 3，需要进行分片但设置了不分片位代码为 4。 第二种是源站抑制，也就是让源站放慢发送速度。 第三种是时间超时，也就是超过网络包的生存时间还是没到。 第四种是路由重定向，也就是让下次发给另一个路由器。 差错报文的结构相对复杂一些。除了前面还是 IP，ICMP 的前 8 字节不变，后面则跟上出错的那个 IP 包 的 IP 头和 IP 正文的前 8 个字节。</description></item><item><title>Mac&amp;IP</title><link>https://no-sky.github.io/2019/macip/</link><pubDate>Fri, 22 Nov 2019 16:40:52 +0800</pubDate><guid>https://no-sky.github.io/2019/macip/</guid><description>Mac头和IP头 在 MAC 头里面，先是目标 MAC 地址，然后是源 MAC 地址，然后有一个协议类型，用来说明里面是 IP 协议。在任何一台机器上，当要访问另一个 IP 地址的时候，都会先判断，这个目标 IP 地址，和当前机器的 IP 地址，是否在同一个网段。怎么判断同一个网段呢？需要 CIDR 和子网掩码。
如果是同一个网段，直接将源地址和目标地址放入 IP 头中，然后通过 ARP 获得 MAC 地址，将源 MAC 和目的 MAC 放入 MAC 头中，发出去就可以了。 如果不是同一网段，这就需要发往默认网关Gateway。Gateway 的地址一定是和源 IP 地址是一个网段的。往往不是第一个，就是第二个。例如192.168.1.0/24 这个网段，Gateway 往往会是 192.168.1.1/24 或192.168.1.2/24。 如何发往默认网关呢？网关不是和源 IP 地址是一个网段的么？这个过程就和发往同一个网段的其他机器 是一样的：将源地址和目标 IP 地址放入 IP 头中，通过 ARP 获得网关的 MAC 地址，将源 MAC 和网关 的 MAC 放入 MAC 头中，发送出去。网关所在的端口，例如 192.168.1.1/24 将网络包收进来，然后接 下来怎么做，就完全看网关的了。 网关往往是一个路由器，是一个三层转发的设备。啥叫三层设备？前面也说过了，就是把 MAC 头和 IP 头都取下来，然后根据里面的内容，看看接下来把包往哪里转发的设备。 在你的宿舍里面，网关就是你宿舍长的电脑。一个路由器往往有多个网口，如果是一台服务器做这个事 情，则就有多个网卡，其中一个网卡是和源 IP 同网段的。 很多情况下，人们把网关就叫作路由器。其实不完全准确，而另一种比喻更加恰当：路由器是一台设 备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的 IP 地址都和局域网的 IP 地址相同的网段，每只手都是它握住的那个局域网的网关。</description></item><item><title>TCP协议</title><link>https://no-sky.github.io/2019/tcp-layer/</link><pubDate>Fri, 22 Nov 2019 16:40:52 +0800</pubDate><guid>https://no-sky.github.io/2019/tcp-layer/</guid><description>TCP协议 TCP协议作为传输层主要协议之一，具有面向连接，端到端，可靠的全双工通信，面向字节流的数据传输协议。
1、TCP报文段 虽然TCP面向字节流，但TCP传输的数据单元却是报文段。TCP报文段分为TCP首部和数据部分，TCP报文段首部的前20个字节是固定的，后面有4*n字节根据需要动态添加的选项，最大长度为40字节。
源端口和目的端口 各占两个字节，TCP的分用功能也是通过端口实现的。 序号 占4个字节，范围是[0,232],TCP是面向字节流的，每个字节都是按顺序编号。例如一个报文段，序号字段是201，携带数据长度是100，那么第一个数据的序号就是201，最后一个就是300。当达到最大范围，又从0开始。 确认号 占4个字节，是期望收到对方下一个报文段的第一个字节的序号。若确认号=N,则表示序号N前所有的数据已经正确收到了。 数据偏移 占4位，表示报文段的数据部分的起始位置，距离整个报文段的起始位置的距离。间接的指出首部的长度。 保留 占6位，保留使用，目前为0. URG（紧急） 当URG=1,表明紧急指针字段有效，该报文段有紧急数据，应尽快发送。 ACK(确认) 仅当ACK=1时，确认号才有效，连接建立后，所有的报文段ACK都为1。 PSH(推送) 接收方接收到PSH=1的报文段，会尽快交付接收应用经常，不再等待整个缓存填满再交付。实际较少使用。 RST(复位) RST=1时，表明TCP连接中出现严重差错，必须是否连接，再重连。 SYN(同步) 在建立连接时用来同步序号。当SYN=1,ACK=0，则表明是一个连接请求报文段。SYN=1,ACK=1则表示对方同意连接。TCP建立连接用到。 FIN(终止) 用来释放一个连接窗口。当FIN=1时，表明此报文段的发送方不再发送数据，请求释放单向连接。TCP断开连接用到。 窗口 占2个字节，表示发送方自己的接收窗口，窗口值用来告诉对方允许发送的数据量。 校验和 占2字节，检验和字段查验范围包括首部和数据部分。 紧急指针 占2字节，URG=1时，紧急指针指出本报文段中的紧急数据的字节数（紧急字节数结束后为普通字节）。 选项 长度可变，最长可达40字节。例如最大报文段长度MSS。MSS指的是数据部分的长度而不是整个TCP报文段长度，MSS默认为536字节长。窗口扩大，时间戳选项等。 2、TCP建立连接-三次握手 三次握手图例如下,与文字解释配合使用效果更佳。
第一次：客户端发送连接请求报文给服务端，其中SYN=1,seq=x。发送完毕后进入SYN_END状态。
第二次：服务端接收到报文后，发回确认报文，其中ACK=1,ack=x+1，因为需要客户端确认，所以报文中也有SYN=1,seq=y的信息。发送完后进入SYN_RCVD状态。
第三次:客户端接收到报文后,发送确认报文，其中ACK=1,ack=y+1。发送完客户端进入ESTABLISHED状态，服务端接收到报文后，进入ESTABLISHED状态。到此，连接建立完成。
三次握手原因
避免资源被浪费掉。如果在第二步握手时，由于网络延迟导致确认包不能及时到达客户端，那么客户端会认为第一次握手失败，再次发送连接请求，服务端收到后再次发送确认包。在这种情况下，服务端已经创建了两次连接，等待两个客户端发送数据，而实际却只有一个客户端发送数据。
3、TCP断开连接-四次挥手 四次挥手指客户端和服务端各发送一次请求终止连接的报文，同时双方响应彼此的请求。 四次挥手图例如下，请配置文字解释使用哦。
第一次挥手：客户端发送FIN=1，seq=x的包给服务端，表示自己没有数据要进行传输，单面连接传输要关闭。发送完后，客户端进入状态。
第二次挥手：服务端收到请求包后，发回ACK=1,ack=x+1的确认包，表示确认断开连接。服务端进入CLOSE_WAIT状态。客户端收到该包后，进入FIN_WAIT_2状态。此时客户端到服务端的数据连接已断开。
第三次挥手：服务端发送FIN=1,seq=y的包给客户端，表示自己没有数据要给客户端了。发送完后进入LAST_ACK状态，等待客户端的确认包。
第四次挥手：客户端收到请求包后，发送ACK=1,ack=y+1的确认包给服务端，并进入TIME_WAIT状态，有可能要重传确认包。服务端收到确认包后，进入CLOSED状态，服务端到客户端的连接已断开。客户端等到一段时间后也会进入CLOSED状态。
四次挥手原因 由于TCP的连接是全双工，双方都可以主动传输数据，一方的断开需要告知对方，让对方可以相关操作，负责任的表现。
使用TCP协议有：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等</description></item><item><title>UDP协议</title><link>https://no-sky.github.io/2019/udp-layer/</link><pubDate>Fri, 22 Nov 2019 16:40:52 +0800</pubDate><guid>https://no-sky.github.io/2019/udp-layer/</guid><description>TCP 和 UDP 有哪些区别？ TCP 是面向连接的，UDP 是面向无连接的。 什么叫面向连接，什么叫无连接呢？在互通之前，面向连接的协议会先建立连接。 所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态， 用这样的数据结构来保证所谓的面向连接的特性。
UDP协议 UDP协议，即用户数据报协议（User Datagram Protocol），是一个简单的面向数据报的传输层协议。UDP协议只在IP数据报服务商增加了很少一点的功能，就是复用和分用，以及差错检测的功能。
UDP协议的主要特点 （1）无连接的
发送数据之前不需要建立连接，减少了开销和发送数据之前的时延。
（2）尽最大努力交付
不保证可靠的交付，主机不需要维持复杂的链接状态表。
（3）面向报文的
发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。
（4）没有拥塞控制。
（5）支持一对一、多对一和多对多的交互通信。
（6）首部开销小，只有8个字节。
UDP数据报的首部结构
用户数据报UDP有两个字段：数据字段和首部字段。首部字段只有8个字节，如下图所示：
UDP首部由4各字段组成，各占两个字节：
（1）源端口
在需要对方回信时使用，不需要时全为0。
（2）目的端口
发送UDP数据报的目的地。
（3）长度
UDP数据报的长度，最短为8个字节，只包含首部。
（4）检验和
用于检验UDP数据报在传输过程中有没有出差错，有则丢弃。</description></item><item><title>图的表示：如何存储微博、微信等社交网络中的好友关系</title><link>https://no-sky.github.io/2019/graph/</link><pubDate>Thu, 21 Nov 2019 21:00:42 +0800</pubDate><guid>https://no-sky.github.io/2019/graph/</guid><description>图的表示：如何存储微博、微信等社交网络中的好友关系 如何理解“图”？ 图中的元素我们就叫作顶点（vertex） 。 图中的一个顶点可以与任意其他顶点建立连接关系。我们把这种建立的关系叫作边（edge）。
就拿微信举例子吧。我们可以把每个用户看作一个顶点。如果两个用户之间互加好友，那就在两者之间建立一条边。所以，整个微信的好友关系就可以用一张图来表示。其中，每个用户有多少个好友，对应到图中，就叫作顶点的度（degree），就是跟顶点相连接的边的条数。
实际上，微博的社交关系跟微信还有点不一样，或者说更加复杂一点。微博允许单向关注，也就是说，用户A关注了用户B，但用户B可以不关注用户A。那我们如何用图来表示这种单向的社交关系呢？
我们可以把刚刚讲的图结构稍微改造一下，引入边的“方向”的概念。
如果用户A关注了用户B，我们就在图中画一条从A到B的带箭头的边，来表示边的方向。如果用户A和用户B互相关注了，那我们就画一条从A指向B的边，再画一条从B指向A的边。我们把这种边有方向的图叫作“有向图”。以此类推，我们把边没有方向的图就叫作“无向图”。
我们刚刚讲过，无向图中有“度”这个概念，表示一个顶点有多少条边。在有向图中，我们把度分为入度（In-degree）和出度（Out-degree）。
顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。对应到微博的例子，入度就表示有多少粉丝，出度就表示关注了多少人。
前面讲到了微信、微博、无向图、有向图，现在我们再来看另一种社交软件：QQ。
QQ中的社交关系要更复杂的一点。不知道你有没有留意过QQ亲密度这样一个功能。QQ不仅记录了用户之间的好友关系，还记录了两个用户之间的亲密度，如果两个用户经常往来，那亲密度就比较高；如果不经常往来，亲密度就比较低。如何在图中记录这种好友关系的亲密度呢？
这里就要用到另一种图，带权图（weighted graph）。在带权图中，每条边都有一个权重（weight），我们可以通过这个权重来表示QQ好友间的亲密度。
关于图的概念比较多，我今天也只是介绍了几个常用的，理解起来都不复杂，不知道你都掌握了没有？掌握了图的概念之后，我们再来看下，如何在内存中存储图这种数据结构呢？
邻接矩阵存储方法 图最直观的一种存储方法就是，邻接矩阵（Adjacency Matrix）。
邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点i与顶点j之间有边，我们就将A[i][j]和A[j][i]标记为1；对于有向图来说，如果顶点i到顶点j之间，有一条箭头从顶点i指向顶点j的边，那我们就将A[i][j]标记为1。同理，如果有一条箭头从顶点j指向顶点i的边，我们就将A[j][i]标记为1。对于带权图，数组中就存储相应的权重。
用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。为什么这么说呢？
对于无向图来说，如果A[i][j]等于1，那A[j][i]也肯定等于1。实际上，我们只需要存储一个就可以了。也就是说，无向图的二维数组中，如果我们将其用对角线划分为上下两部分，那我们只需要利用上面或者下面这样一半的空间就足够了，另外一半白白浪费掉了。
还有，如果我们存储的是稀疏图（Sparse Matrix），也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。比如微信有好几亿的用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。如果我们用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。
但这也并不是说，邻接矩阵的存储方法就完全没有优点。首先，邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。比如求解最短路径问题时会提到一个Floyd-Warshall算法，就是利用矩阵循环相乘若干次得到结果。
邻接表存储方法 针对上面邻接矩阵比较浪费内存空间的问题，我们来看另外一种图的存储方法，邻接表（Adjacency List）。
我画了一张邻接表的图，你可以先看下。乍一看，邻接表是不是有点像散列表？每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。另外我需要说明一下，图中画的是一个有向图的邻接表存储方式，每个顶点对应的链表里面，存储的是指向的顶点。对于无向图来说，也是类似的，不过，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点，你可以自己画下。
还记得我们之前讲过的时间、空间复杂度互换的设计思想吗？邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。
就像图中的例子，如果我们要确定，是否存在一条从顶点2到顶点4的边，那我们就要遍历顶点2对应的那条链表，看链表中是否存在顶点4。而且，我们前面也讲过，链表的存储方式对缓存不友好。所以，比起邻接矩阵的存储方式，在邻接表中查询两个顶点之间的关系就没那么高效了。
在散列表那几节里，我讲到，在基于链表法解决冲突的散列表中，如果链过长，为了提高查找效率，我们可以将链表换成其他更加高效的数据结构，比如平衡二叉查找树等。我们刚刚也讲到，邻接表长得很像散列。所以，我们也可以将邻接表同散列表一样进行“改进升级”。
我们可以将邻接表中的链表改成平衡二叉查找树。实际开发中，我们可以选择用红黑树。这样，我们就可以更加快速地查找两个顶点之间是否存在边了。当然，这里的二叉查找树可以换成其他动态数据结构，比如跳表、散列表等。除此之外，我们还可以将链表改成有序动态数组，可以通过二分查找的方法来快速定位两个顶点之间否是存在边。</description></item><item><title>二叉树基础：什么样的二叉树适合用数组来存储</title><link>https://no-sky.github.io/2019/binary-tree/</link><pubDate>Thu, 21 Nov 2019 10:47:52 +0800</pubDate><guid>https://no-sky.github.io/2019/binary-tree/</guid><description>树（Tree） 比如下面这幅图，A节点就是B节点的父节点，B节点是A节点的子节点。B、C、D这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。我们把没有父节点的节点叫作根节点，也就是图中的节点E。我们把没有子节点的节点叫作叶子节点或者叶节点，比如图中的G、H、I、J、K、L都是叶子节点。
除此之外，关于“树”，还有三个比较相似的概念：高度（Height）、深度（Depth）、层（Level）。它们的定义是这样的：
二叉树（Binary Tree） 二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。
这个图里面，有两个比较特殊的二叉树，分别是编号2和编号3这两个。
其中，编号2的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作满二叉树。
编号3的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作完全二叉树
如何表示（或者存储）一棵二叉树？ 一种是基于指针或者引用的二叉链式存储法
每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。
一种是基于数组的顺序存储法。
把根节点存储在下标i = 1的位置，那左子节点存储在下标2 * i = 2的位置，右子节点存储在2 * i + 1 = 3的位置。以此类推，B节点的左子节点存储在2 * i = 2 * 2 = 4的位置，右子节点存储在2 * i + 1 = 2 * 2 + 1 = 5的位置。
如果节点X存储在数组中下标为i的位置，下标为2 * i 的位置存储的就是左子节点，下标为2 * i + 1的位置存储的就是右子节点。反过来，下标为i/2的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为1的位置），这样就可以通过下标计算，把整棵树都串起来。
不过，我刚刚举的例子是一棵完全二叉树，所以仅仅“浪费”了一个下标为0的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间。你可以看我举的下面这个例子。
所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。
当我们讲到堆和堆排序的时候，你会发现，堆其实就是一种完全二叉树，最常用的存储方式就是数组。
二叉树的遍历 前面我讲了二叉树的基本定义和存储方法，现在我们来看二叉树中非常重要的操作，二叉树的遍历。这也是非常常见的面试题。
如何将所有节点都遍历打印出来呢？经典的方法有三种，前序遍历、中序遍历和后序遍历。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。
前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。 实际上，二叉树的前、中、后序遍历就是一个递归的过程。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。</description></item><item><title>红黑树：为什么工程中都用红黑树这种二叉树</title><link>https://no-sky.github.io/2019/red-blac-tree/</link><pubDate>Thu, 21 Nov 2019 10:47:52 +0800</pubDate><guid>https://no-sky.github.io/2019/red-blac-tree/</guid><description>什么是“平衡二叉查找树”？ 平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于1。从这个定义来看，上一节我们讲的完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。
平衡二叉查找树不仅满足上面平衡二叉树的定义，还满足二叉查找树的特点。最先被发明的平衡二叉查找树是AVL树，它严格符合我刚讲到的平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过1，是一种高度平衡的二叉查找树。
发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。
所以，平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。
如何定义一棵“红黑树”？ 红黑树的英文是“Red-Black Tree”，简称R-B Tree。它是一种不严格的平衡二叉查找树，它的定义是不严格符合平衡二叉查找树的定义的。那红黑树究竟是怎么定义的呢？
顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：
根节点是黑色的； 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据； 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的； 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点； 解答开篇 我们刚刚提到了很多平衡二叉查找树，现在我们就来看下，为什么在工程中大家都喜欢用红黑树这种平衡二叉查找树？
我们前面提到Treap、Splay Tree，绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用。
AVL树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用AVL树的代价就有点高了。
红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比AVL树要低。
所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。</description></item><item><title>二分查找（上）：如何用最省内存的方式实现快速查找功能</title><link>https://no-sky.github.io/2019/binary-search/</link><pubDate>Wed, 20 Nov 2019 09:00:52 +0800</pubDate><guid>https://no-sky.github.io/2019/binary-search/</guid><description>二分查找（上）：如何用最省内存的方式实现快速查找功能 二分查找（Binary Search）算法，也叫折半查找算法。
无处不在的二分思想 二分查找是一种非常简单易懂的快速查找算法，生活中到处可见。比如说，我们现在来做一个猜字游戏。我随机写一个0到99之间的数字，然后你来猜我写的是什么。猜的过程中，你每猜一次，我就会告诉你猜的大了还是小了，直到猜中为止。你来想想，如何快速猜中我写的数字呢？
假设我写的数字是23，你可以按照下面的步骤来试一试。（如果猜测范围的数字有偶数个，中间数有两个，就选择较小的那个。）
7次就猜出来了，是不是很快？这个例子用的就是二分思想。
二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0。
O(logn)惊人的查找速度 二分查找是一种非常高效的查找算法，高效到什么程度呢？我们来分析一下它的时间复杂度。
我们假设数据大小是n，每次查找后数据都会缩小为原来的一半，也就是会除以2。最坏情况下，直到查找区间被缩小为空，才停止。
可以看出来，这是一个等比数列。其中n/2k=1时，k的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了k次区间缩小操作，时间复杂度就是O(k)。通过n/2k=1，我们可以求得k=log2n，所以时间复杂度就是O(logn)。 O(logn)这种对数时间复杂度。这是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级O(1)的算法还要高效。
二分查找应用场景的局限性 首先，二分查找依赖的是顺序表结构，简单点说就是数组。
二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。
其次，二分查找针对的是有序数据。
二分查找对这一点的要求比较苛刻，数据必须是有序的。如果数据没有序，我们需要先排序。
再次，数据量太小不适合二分查找。
最后，数据量太大也不适合二分查找。
二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有1GB大小的数据，如果希望用数组来存储，那就需要1GB的连续内存空间。</description></item><item><title>哈希算法：如何防止数据库中的用户信息被脱库</title><link>https://no-sky.github.io/2019/hash-algrothm/</link><pubDate>Wed, 20 Nov 2019 09:00:52 +0800</pubDate><guid>https://no-sky.github.io/2019/hash-algrothm/</guid><description>哈希算法：如何防止数据库中的用户信息被脱库 什么是哈希算法？ 哈希算法的定义和原理非常简单，基本上一句话就可以概括了。将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。但是，要想设计一个优秀的哈希算法并不容易，根据我的经验，我总结了需要满足的几点要求：
从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）； 对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也大不相同； 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小； 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。 哈希算法的应用 应用一：安全加密 最常用于加密的哈希算法是MD5（MD5 Message-Digest Algorithm，MD5消息摘要算法）和SHA（Secure Hash Algorithm，安全散列算法）。
除了这两个之外，当然还有很多其他加密算法，比如DES（Data Encryption Standard，数据加密标准）、AES（Advanced Encryption Standard，高级加密标准）。
对用于加密的哈希算法来说，有两点格外重要。第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。
应用二：唯一标识 我们知道，任何文件在计算中都可以表示成二进制码串， 我们可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制码串开头取100个字节，从中间取100个字节，从最后再取100个字节，然后将这300个字节放到一块，通过哈希算法（比如MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。
应用三：数据校验 我们通过哈希算法，对100个文件块分别取哈希值，并且保存在种子文件中。我们在前面讲过，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。
应用四：散列函数 实际上，散列函数也是哈希算法的一种应用。
解答开篇 好了，有了前面的基础，现在你有没有发现开篇的问题其实很好解决？
我们可以通过哈希算法，对用户密码进行加密之后再存储，不过最好选择相对安全的加密算法，比如SHA等（因为MD5已经号称被破解了）。不过仅仅这样加密之后存储就万事大吉了吗？
字典攻击你听说过吗？如果用户信息被“脱库”，黑客虽然拿到是加密之后的密文，但可以通过“猜”的方式来破解密码，这是因为，有些用户的密码太简单。比如很多人习惯用00000、123456这样的简单数字组合做密码，很容易就被猜中。
那我们就需要维护一个常用密码的字典表，把字典中的每个密码用哈希算法计算哈希值，然后拿哈希值跟脱库后的密文比对。如果相同，基本上就可以认为，这个加密之后的密码对应的明文就是字典中的这个密码。（注意，这里说是的是“基本上可以认为”，因为根据我们前面的学习，哈希算法存在散列冲突，也有可能出现，尽管密文一样，但是明文并不一样的情况。）
针对字典攻击，我们可以引入一个盐（salt），跟用户的密码组合在一起，增加密码的复杂度。我们拿组合之后的字符串来做哈希算法加密，将它存储到数据库中，进一步增加破解的难度。不过我这里想多说一句，我认为安全和攻击是一种博弈关系，不存在绝对的安全。所有的安全措施，只是增加攻击的成本而已。</description></item><item><title>排序</title><link>https://no-sky.github.io/2019/sort/</link><pubDate>Wed, 20 Nov 2019 09:00:52 +0800</pubDate><guid>https://no-sky.github.io/2019/sort/</guid><description>如何分析一个“排序算法”？ 学习排序算法，我们除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。那分析一个排序算法，要从哪几个方面入手呢？
排序算法的执行效率 对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：
1.最好情况、最坏情况、平均情况时间复杂度 n
我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。
为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。
2.时间复杂度的系数、常数 、低阶
我们知道，时间复杂度反应的是数据规模n很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是10个、100个、1000个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。
3.比较次数和交换（或移动）次数
基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。
排序算法的内存消耗 算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是O(1)的排序算法。
排序算法的稳定性 仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。
我通过一个例子来解释一下。比如我们有一组数据2，9，3，4，8，3，按照大小排序之后就是2，3，3，4，8，9。
这组数据里有两个3。经过某种排序算法排序之后，如果两个3的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。
稳定排序算法可以保持数额相同的两个对象，在排序之后的前后顺序不变。</description></item><item><title>排序优化：如何实现一个通用的、高性能的排序函数</title><link>https://no-sky.github.io/2019/sort-optimization/</link><pubDate>Wed, 20 Nov 2019 09:00:52 +0800</pubDate><guid>https://no-sky.github.io/2019/sort-optimization/</guid><description>排序优化：如何实现一个通用的、高性能的排序函数 如何选择合适的排序算法？ 如果要实现一个通用的、高效率的排序函数，我们应该选择哪种排序算法？
线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。
如果对小规模数据进行排序，可以选择时间复杂度是O(n^2)的算法；如果对大规模数据进行排序，时间复杂度是O(nlogn)的算法更加高效。所以**，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是O(nlogn)的排序算法来实现排序函数。**
时间复杂度是O(nlogn)的排序算法不止一个，我们已经讲过的有归并排序、快速排序，后面讲堆的时候我们还会讲到堆排序。堆排序和快速排序都有比较多的应用，比如Java语言采用堆排序实现排序函数，C语言使用快速排序实现排序函数。
不知道你有没有发现，使用归并排序的情况其实并不多。我们知道，快排在最坏情况下的时间复杂度是O(n2)，而归并排序可以做到平均情况、最坏情况下的时间复杂度都是O(nlogn)，从这点上看起来很诱人，那为什么它还是没能得到“宠信”呢？
还记得我们上一节讲的归并排序的空间复杂度吗？归并排序并不是原地排序算法，空间复杂度是O(n)。所以，粗略点、夸张点讲，如果要排序100MB的数据，除了数据本身占用的内存之外，排序算法还要额外再占用100MB的内存空间，空间耗费就翻倍了。
前面我们讲到，快速排序比较适合来实现排序函数，但是，我们也知道，快速排序在最坏情况下的时间复杂度是O(n^2)，如何来解决这个“复杂度恶化”的问题呢？
如何优化快速排序？ 我们先来看下，为什么最坏情况下快速排序的时间复杂度是O(n^2)呢？我们前面讲过，如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为O(n^2)。实际上，这种O(n^2)时间复杂度出现的主要原因还是因为我们分区点选的不够合理。
那什么样的分区点是好的分区点呢？或者说如何来选择分区点呢？
最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。
1.三数取中法 我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这3个数的中间值作为分区点。
2.随机法 随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。</description></item><item><title>散列表：Word文档中的单词拼写检查功能是如何实现的</title><link>https://no-sky.github.io/2019/hashtable/</link><pubDate>Wed, 20 Nov 2019 09:00:52 +0800</pubDate><guid>https://no-sky.github.io/2019/hashtable/</guid><description>散列表：Word文档中的单词拼写检查功能是如何实现的 散列思想 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。
散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是O(1)的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。
散列函数 散列函数，顾名思义，它是一个函数。我们可以把它定义成hash(key)，其中key表示元素的键值，hash(key)的值表示经过散列函数计算得到的散列值。
该如何构造散列函数呢？我总结了三点散列函数设计的基本要求：
散列函数计算得到的散列值是一个非负整数； 如果key1 = key2，那hash(key1) == hash(key2)； 如果key1 ≠ key2，那hash(key1) ≠ hash(key2)。 我们几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，我们需要通过其他途径来解决。
解答开篇 有了前面这些基本知识储备，我们来看一下开篇的思考题：Word文档中单词拼写检查功能是如何实现的？
常用的英文单词有20万个左右，假设单词的平均长度是10个字母，平均一个单词占用10个字节的内存空间，那20万英文单词大约占2MB的存储空间，就算放大10倍也就是20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。
当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</description></item><item><title>跳表</title><link>https://no-sky.github.io/2019/skip-list/</link><pubDate>Wed, 20 Nov 2019 09:00:52 +0800</pubDate><guid>https://no-sky.github.io/2019/skip-list/</guid><description>如何理解“跳表”？ 对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是O(n)。
那怎么来提高查找效率呢？如果像图中那样，对链表建立一级“索引”，查找起来是不是就会更快一些呢？每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引或索引层。你可以看我画的图。图中的down表示down指针，指向下一级结点。
如果我们现在要查找某个结点，比如16。我们可以先在索引层遍历，当遍历到索引层中值为13的结点时，我们发现下一个结点是17，那要查找的结点16肯定就在这两个结点之间。然后我们通过索引层结点的down指针，下降到原始链表这一层，继续遍历。这个时候，我们只需要再遍历2个结点，就可以找到值等于16的这个结点了。这样，原来如果要查找16，需要遍历10个结点，现在只需要遍历7个结点。
从这个例子里，我们看出，加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了。那如果我们再加一级索引呢？效率会不会提升更多呢？
跟前面建立第一级索引的方式相似，我们在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引。现在我们再来查找16，只需要遍历6个结点了，需要遍历的结点数量又减少了。
我举的例子数据量不大，所以即便加了两级索引，查找效率的提升也并不明显。为了让你能真切地感受索引提升查询效率。我画了一个包含64个结点的链表，按照前面讲的这种思路，建立了五级索引。
从图中我们可以看出，原来没有索引的时候，查找62需要遍历62个结点，现在只需要遍历11个结点，速度是不是提高了很多？所以，当链表的长度n比较大时，比如1000、10000的时候，在构建索引之后，查找效率的提升就会非常明显。
前面讲的这种链表加多级索引的结构，就是跳表。我通过例子给你展示了跳表是如何减少查询次数的，现在你应该比较清晰地知道，跳表确实是可以提高查询效率的。</description></item><item><title>递归</title><link>https://no-sky.github.io/2019/recursion/</link><pubDate>Wed, 20 Nov 2019 09:00:52 +0800</pubDate><guid>https://no-sky.github.io/2019/recursion/</guid><description>递归 如何理解“递归”？ 递归是一种应用非常广泛的算法（或者编程技巧）。之后我们要讲的很多数据结构和算法的编码实现都要用到递归，比如DFS深度优先搜索、前中后序二叉树遍历等等。
周末你带着女朋友去电影院看电影，女朋友问你，咱们现在坐在第几排啊？电影院里面太黑了，看不清，没法数，现在你怎么办？
别忘了你是程序员，这个可难不倒你，递归就开始派上用场了。于是你就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。
这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。刚刚这个生活中的例子，我们用递推公式将它表示出来就是这样的：
f(n)=f(n-1)+1 其中，f(1)=1 f(n)表示你想知道自己在哪一排，f(n-1)表示前面一排所在的排数，f(1)=1表示第一排的人知道自己在第一排。有了这个递推公式，我们就可以很轻松地将它改为递归代码，如下：
int f(int n) { if (n == 1) return 1; return f(n-1) + 1; } 递归需要满足的三个条件 刚刚这个例子是非常典型的递归，那究竟什么样的问题可以用递归来解决呢？有三个条件，只要同时满足以下三个条件，就可以用递归来解决。
1.一个问题的解可以分解为几个子问题的解
何为子问题？子问题就是数据规模更小的问题。比如，前面讲的电影院的例子，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。
2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
比如电影院那个例子，你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的。
3.存在递归终止条件
把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。
还是电影院的例子，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是f(1)=1，这就是递归的终止条件。
如何编写递归代码？ 写递归代码最关键的是写出递推公式，找到终止条件，剩下将递推公式转化为代码就很简单了。
假如这里有n个台阶，每次你可以跨1个台阶或者2个台阶，请问走这n个台阶有多少种走法？如果有7个台阶，你可以2，2，2，1这样子上去，也可以1，2，1，1，2这样子上去，总之走法有很多，那如何用编程求得总共有多少 种走法呢？
我们仔细想下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了1个台阶，另一类是第一步走了2个台阶。所以n个台阶的走法就等于先走1阶后，n-1个台阶的走法 加上先走2阶后，n-2个台阶的走法。用公式表示就是：
f(n) = f(n-1)+f(n-2) 有了递推公式，递归代码基本上就完成了一半。我们再来看下终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法。所以f(1)=1。这个递归终止条件足够吗？我们可以用n=2，n=3这样比较小的数试验一下。
n=2时，f(2)=f(1)+f(0)。如果递归终止条件只有一个f(1)=1，那f(2)就无法求解了。所以除了f(1)=1这一个递归终止条件外，还要有f(0)=1，表示走0个台阶有一种走法，不过这样子看起来就不符合正常的逻辑思维了。所以，我们可以把f(2)=2作为一种终止条件，表示走2个台阶，有两种走法，一步走完或者分两步来走。
所以，递归终止条件就是f(1)=1，f(2)=2。这个时候，你可以再拿n=3，n=4来验证一下，这个终止条件是否足够并且正确。
我们把递归终止条件和刚刚得到的递推公式放到一起就是这样的：
f(1) = 1; f(2) = 2; f(n) = f(n-1)+f(n-2) 有了这个公式，我们转化成递归代码就简单多了。最终的递归代码是这样的：
int f(int n) { if (n == 1) return 1; if (n == 2) return 2; return f(n-1) + f(n-2); } 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</description></item><item><title>队列：队列在线程池等有限资源池中的应用</title><link>https://no-sky.github.io/2019/queue/</link><pubDate>Tue, 19 Nov 2019 22:44:52 +0800</pubDate><guid>https://no-sky.github.io/2019/queue/</guid><description>队列：队列在线程池等有限资源池中的应用 如何理解“队列”？ 队列这个概念非常好理解。你可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。先进者先出，这就是典型的队列。
我们知道，栈只支持两个基本操作：入栈push()**和**出栈pop()。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：入队enqueue()，放一个数据到队列尾部；出队dequeue()，从队列头部取一个元素。
所以，队列跟栈一样，也是一种操作受限的线性表数据结构。
队列的概念很好理解，基本操作也很容易掌握。作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列Disruptor、Linux环形缓存，都用到了循环并发队列；Java concurrent并发包利用ArrayBlockingQueue来实现公平锁等。
顺序队列和链式队列 队列跟栈一样，也是一种抽象的数据结构。它具有先进先出的特性，支持在队尾插入元素，在队头删除元素，那究竟该如何实现一个队列呢？
跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。
解答开篇 队列的知识就讲完了，我们现在回过来看下开篇的问题。线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？
我们一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？
我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。我们前面说过，队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？
基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。
而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。
除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</description></item><item><title>链表</title><link>https://no-sky.github.io/2019/linkedlist/</link><pubDate>Mon, 18 Nov 2019 22:35:42 +0800</pubDate><guid>https://no-sky.github.io/2019/linkedlist/</guid><description>链表 数组需要一块连续的内存空间来存储，对内存的要求比较高。如果我们申请一个100MB大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于100MB，仍然会申请失败。
而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用，所以如果我们申请的是100MB大小的链表，根本不会有问题。
单链表 链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作后继指针next。
其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作头结点，把最后一个结点叫作尾结点。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址NULL，表示这是链表上最后一个结点。
链表的插入与删除循环链表和双向链表 循环链表是一种特殊的单链表。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。
单向链表只有一个方向，结点只有一个后继指针next指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。</description></item><item><title>栈：如何实现浏览器的前进和后退功能</title><link>https://no-sky.github.io/2019/stack/</link><pubDate>Mon, 18 Nov 2019 22:16:52 +0800</pubDate><guid>https://no-sky.github.io/2019/stack/</guid><description>栈：如何实现浏览器的前进和后退功能 如何理解“栈”？ 关于“栈”，我有一个非常贴切的例子，就是一摞叠在一起的盘子。我们平时放盘子的时候，都是从下往上一个一个放；取的时候，我们也是从上往下一个一个地依次取，不能从中间任意抽出。后进者先出，先进者后出，这就是典型的“栈”结构。
从栈的操作特性上来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。
当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。
如何实现一个“栈”？ 从刚才栈的定义里，我们可以看出，栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。理解了栈的定义之后，我们来看一看如何用代码实现一个栈。
实际上，栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。
空间复杂度分析和时间复杂度，不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是O(1)。
栈的应用 栈在函数调用中的应用 栈在表达式求值中的应用 栈在括号匹配中的应用
如何实现浏览器的前进、后退功能？ 其实，用两个栈就可以非常完美地解决这个问题。
我们使用两个栈，X和Y，我们把首次浏览的页面依次压入栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据依次放入栈Y。当我们点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，那就说明没有页面可以继续后退浏览了。当栈Y中没有数据，那就说明没有页面可以点击前进按钮浏览了。
比如你顺序查看了a，b，c三个页面，我们就依次把a，b，c压入栈，这个时候，两个栈的数据就是这个样子：
当你通过浏览器的后退按钮，从页面c后退到页面a之后，我们就依次把c和b从栈X中弹出，并且依次放入到栈Y。这个时候，两个栈的数据就是这个样子：
这个时候你又想看页面b，于是你又点击前进按钮回到b页面，我们就把b再从栈Y中出栈，放入栈X中。此时两个栈的数据是这个样子：
这个时候，你通过页面b又跳转到新的页面d了，页面c就无法再通过前进、后退按钮重复查看了，所以需要清空栈Y。此时两个栈的数据这个样子：</description></item><item><title>数组：为什么很多编程语言中数组都从0开始编号</title><link>https://no-sky.github.io/2019/array/</link><pubDate>Thu, 14 Nov 2019 17:16:42 +0800</pubDate><guid>https://no-sky.github.io/2019/array/</guid><description>数组：为什么很多编程语言中数组都从0开始编号 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
如何实现随机访问？ 第一要是线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。 非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。
第二 具有连续的内存空间和相同类型的数据。
但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。
根据下标随机访问 我们拿一个长度为10的int类型的数组int[] a = new int[10]来举例。在我画的这个图中，计算机给数组a[10]，分配了一块连续内存空间1000～1039，其中，内存块的首地址为base_address = 1000。
我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：
a[i]_address = base_address + i * data_type_size 其中data_type_size表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是int类型数据，所以data_type_size就为4个字节。
这里我要特别纠正一个“错误”。我在面试的时候，常常会问数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度O(1)；数组适合查找，查找时间复杂度为O(1)”。
实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。
解答开篇 现在我们来思考开篇的问题：为什么大多数编程语言中，数组要从0开始编号，而不是从1开始呢？
从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就表示偏移k个type_size的位置，所以计算a[k]的内存地址只需要用这个公式：
a[k]_address = base_address + k * type_size 但是，如果数组从1开始计数，那我们计算数组元素a[k]的内存地址就会变为：
a[k]_address = base_address + (k-1)*type_size 对比两个公式，我们不难发现，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。
数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从0开始编号，而不是从1开始。
不过我认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非0开始不可。所以我觉得最主要的原因可能是历史原因。
C语言设计者用0开始计数数组下标，之后的Java、JavaScript等高级语言都效仿了C语言，或者说，为了在一定程度上减少C语言程序员学习Java的学习成本，因此继续沿用了从0开始计数的习惯。实际上，很多语言中数组也并不是从0开始计数的，比如Matlab。甚至还有一些语言支持负数下标，比如Python。</description></item><item><title>复杂度分析：如何分析算法的执行效率和资源消耗</title><link>https://no-sky.github.io/2019/complexity-analysis/</link><pubDate>Wed, 13 Nov 2019 21:00:42 +0800</pubDate><guid>https://no-sky.github.io/2019/complexity-analysis/</guid><description>复杂度分析：如何分析算法的执行效率和资源消耗 大O复杂度表示法 ​ $T(n) = O(f(n))$
其中，T(n)表示代码执行的时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。因为这是一个公式，所以用f(n)来表示。公式中的O，表示代码的执行时间T(n)与f(n)表达式成正比。
大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。
时间复杂度分析 1.只关注循环执行次数最多的一段代码 我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的n的量级，就是整段要分析代码的时间复杂度。
2.加法法则：总复杂度等于量级最大的那段代码的复杂度 总的时间复杂度就等于量级最大的那段代码的时间复杂度。那我们将这个规律抽象成公式就是：
如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).
3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).
也就是说，假设T1(n) = O(n)，T2(n) = O(n2)，则T1(n) * T2(n) = O(n3)。落实到具体的代码上，我们可以把乘法法则看成是嵌套循环，例子:
int cal(int n) { int ret = 0; int i = 1; for (; i &amp;lt; n; ++i) { ret = ret + f(i); } } int f(int n) { int sum = 0; int i = 1; for (; i &amp;lt; n; ++i) { sum = sum + i; } return sum; } 我们单独看cal()函数。假设f()只是一个普通的操作，那第4～6行的时间复杂度就是，T1(n) = O(n)。但f()函数本身不是一个简单的操作，它的时间复杂度是T2(n) = O(n)，所以，整个cal()函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n2)。</description></item><item><title> 导数的应用</title><link>https://no-sky.github.io/2019/application-of-derivative/</link><pubDate>Mon, 29 Apr 2019 16:22:53 +0800</pubDate><guid>https://no-sky.github.io/2019/application-of-derivative/</guid><description>切线和法线方程 ${f}'(x_0)$在几何上表示曲线$y=f(x)$在$(x_0,f(x_0))$处的切线斜率
切线方程：$y-y_0={f}'(x_0)(x-X_0)$
法线方程：$y-y_0=-\frac{1}{{f}'(x_0)}(x-x_0)$
求隐函数的导数 （1）定义：显函数$y=f(x)$，隐函数$F(x,y)$
（2）方法：方程两边同时对$x$求导，接触${y}'$
例：设$x^2y-e^{2x}=\sin y$，求$\frac{\mathrm{d}y}{\mathrm{d}x}$.
解：$方程两边同时对x求导得： \\\\ 2xy+x^2·{y}'-2·e^{2x}={y}'·\cos y \\\\ (x^2-\cos y)·{y}'=2e^{2x}-2xy \\\\ {y}'=\frac{2e^{2x}-2xy}{x^2-\cos y}$
求幂指函数的导数 方法一：先取对数再求导（对数求导法）
方法二：化为以$e$为底的指数函数后再求导（$y=u^x=e^{xlnu}$）
例：求$y=x^{\sin x}$ 函数的导数$\frac{\mathrm{d}y}{\mathrm{d}x}$
解：法一：$方程两边同时取对数：lny=lnx^{\sin x}=\sin xlnx \\\\ 方程两边同时对x求导：\frac{1}{y}·{y}'=\cos x · lnx+\sin x·\frac{1}{x} \\\\ \Rightarrow {y}'=y(\cos x lnx+\frac{\sin x}{x}) \\\\ \Rightarrow {y}'=x^{\sin x}(\cos x lnx+\frac{\sin x}{x})$
​ 法二：$y=x^{\sin x}=e^{\sin xlnx} \\\\ ​ {y}'=e^{\sin xlnx}{(\sin xlnx)}'=x^{\sin x}(\cos xlnx+\frac{\sin x}{x})$
求由参数方程确定的函数的导数 （1）参数方程：$\left\{\begin{matrix} x=\varphi(t) \\\\ y=\psi(t) \end{matrix}\right.$
（2）求导方法：$\frac{\mathrm{d}y}{\mathrm{d}x}=\frac{\frac{\mathrm{d}y}{\mathrm{d}t}}{\frac{\mathrm{d}x}{\mathrm{d}t}}=\frac{{\varphi}'(t)}{{\psi}'(t)} \\\\ \frac{\mathrm{d^2}y}{\mathrm{d}x^2}=\frac{\mathrm{d}}{\mathrm{d}x}(\frac{\mathrm{d}y}{\mathrm{d}x})=\frac{\frac{\mathrm{d}(\frac{\mathrm{d}y}{\mathrm{d}x})}{\mathrm{d}t}}{\frac{\mathrm{d}x}{\mathrm{d}t}}$
求微分 1、对于一元函数，可微$\Leftrightarrow$可导</description></item><item><title>微分中值定理和导数的应用</title><link>https://no-sky.github.io/2019/application-of-differential-mean-value-theorem/</link><pubDate>Sun, 28 Apr 2019 15:51:26 +0800</pubDate><guid>https://no-sky.github.io/2019/application-of-differential-mean-value-theorem/</guid><description>因为文章中包含大量数学公式，推荐使用电脑阅读本文章
利用罗尔中值定理证明根的存在性 例：设函数$f(x)$在闭区间$[0,1]$上连续，在开区间$(0,1)$内可导，且$f(0)=0,f(1)=2$，证明：在$(0,1)$内至少存在一点$\xi$，使得${f}'(\xi )=2\xi +1$成立。
证：$（思路）构建辅助函数，得出原函数：\left\{\begin{matrix} {f}'=2x+1\\\\ {f}'-2x-1=0'\\\\ f(x)-x^2-x=0 \end{matrix}\right.$
$①设F(x)=f(x)-x^2-x \\\\ ②\because f(x)在闭区间[0,1]上连续，开区间(0,1)内可导 \\\\ \therefore F(x)在[0,1]上连续，(01,)内可导, \\\\ F(0)=f(0)=0,F(1)=f(1)-1-1=0 \\\\ ③ 故，由罗尔定理可知, \exists \xi \in (0,1),使得{F}'(\xi )=0,即{f}'(\xi )=2\xi +1$
利用拉格朗日中值定理证明不等式 （1）构造辅助函数$f(x)$将中间部分写成差的形式，确定$f(x)$及区间$[a,b]$.
（2）验证拉格朗日中值定理的两个条件.
（3）利用拉格朗日中值定理的结论得到等式.
（4）利用$\xi$或${f}'(\xi )$的取值范围得到不等式
例：证明不等式$\frac{m-n}{m}&amp;lt;ln\frac{m}{n}&amp;lt;\frac{m-n}{n}$，其中$n&amp;lt;m$为正整数。
证：$①令f(0)=lnx,x\in [n,m] \\\\ ②显然f(x)在[n,m]上连续，(n,m)内可导. \\\\ ③故，由拉格朗日中值定理可得，\\\\ \exists \xi \in (n,m),使得{f}'(\xi )=\frac{f(m)-f(n)}{m-n}=\frac{lnm-lnn}{m-n}=\frac{ln\frac{m}{n}}{m-n} \\\\ \because {f}'(x)=\frac{1}{x},{f}'(\xi )=\frac{1}{\xi} \therefore \frac{1}{\xi}=\frac{ln\frac{m}{n}}{m-n} \\\\ ④\because n&amp;lt; \xi &amp;lt;m,\therefore \frac{1}{m}&amp;lt;\frac{1}{\xi}&amp;lt;\frac{1}{n} \\\\ \therefore \frac{1}{m}&amp;lt;\frac{ln\frac{m}{n}}{m-n}&amp;lt;\frac{1}{n} \therefore \frac{m-n}{m}&amp;lt;ln\frac{m}{n}&amp;lt;\frac{m-n}{n}$
利用单调性证明不等式 （1）构造辅助函数：移项
（2）求导，判断单调性，若不能判断，继续求导，直至能判断为止（最多三阶可导）
（3）结合区间端点，利用单调性完成不等式的证明</description></item><item><title>微分中值定理与洛必达法则</title><link>https://no-sky.github.io/2019/mean-value-theorem/</link><pubDate>Sun, 28 Apr 2019 14:53:56 +0800</pubDate><guid>https://no-sky.github.io/2019/mean-value-theorem/</guid><description>因为文章中包含大量数学公式，推荐使用电脑阅读本文章
罗尔定理 如果函数$f(x)$满足
①在闭区间$[a,b]$上连续
②在开区间$(a,b)$内可导
③在区间端点处的函数值相等，即$f(a)=f(b)$，那么在$(a,b)$内至少有一点$\xi (a&amp;lt; \xi &amp;lt;b),使得{f}'(\xi )=0$
拉格朗日中值定理 如果函数$f(x)$满足
①在闭区间$[a,b]$上连续
②在开区间$(a,b)$内可导
那么在$(a,b)$内至少有一点$\xi (a&amp;lt; \xi &amp;lt;b)，使等式f(b)-f(a)={f}'(\xi )(b-a)成立$
柯西中值定理 如果函数$f(x)及F(x)$满足
①在闭区间$[a,b]$上连续
②在开区间$(a,b)$内可导
③对任一$x\in (a,b),{F}'(x)\neq 0$，那么在$(a,b)$内至少有一点$\xi (a&amp;lt; \xi &amp;lt;b)$，使等式$\frac{f(b)-f(a)}{F(b)-F(a)}=\frac{{f}'(\xi )}{{F}'(\xi )}$
洛必达法则 设①当$x \Rightarrow a$时，函数$f(x)$及$F(x)$都趋于零；
②在点a的某去心邻域内，${f}'(x)$及${F}'(x)$都存在且${F}'(x)\neq 0$
③$\lim_{x \to a} \frac{{f}'(x)}{{F}'(x)}$存在（或为无穷大），那么
其中$\frac{f(x)}{F(x)}$也可以是$\frac{\infty}{\infty}$型未定式，${f}'(x),{F}'(x)$要存在且${F}'(x)\neq 0$；相同的极限过程可以是$x\rightarrow a,x \rightarrow a^{\pm },x \rightarrow \infty,x\rightarrow \pm \infty $的任何一种，对于$n \rightarrow \infty$，可用于子列极限定理，先化为$x \Rightarrow +\infty$的极限
对于其余五种非基本型未定式，应先变形或者取对数化为基本型，再用洛必达法则。</description></item><item><title>不定积分</title><link>https://no-sky.github.io/2019/indefinite-integral/</link><pubDate>Sat, 27 Apr 2019 15:57:22 +0800</pubDate><guid>https://no-sky.github.io/2019/indefinite-integral/</guid><description>因为文章中包含大量数学公式，推荐使用电脑阅读本文章
原函数与不定积分的概念 原函数 若对于某区间$I$上任意一点$x$，均有${F}'(x)=f(x)或\mathrm{d}F(x)=f(x)\mathrm{d}x$，则称$F(x)$是$f(x)$在$I$上的一个原函数。
原函数存在定理 如果函数$f(x)$在区间$I$上连续，那么在区间$I$上存在可导函数$F(x)$，使对任意$x \in I$都有${F}'(x)=f(x)$。
不定积分 $f(x)$在区间$I$上的原函数全体称为f(x)在$I$上的不定积分，即若$F(x)$是$f(x)$在$I$上的任一原函数，则$\int f(x)\mathrm{d}x=F(x)+C(C为任意常数)$.
由此定义可得下列关系：
（1）${\int f(x)\mathrm{d}x}'=f(x)$ 或 $\mathrm{\int f(x)\mathrm{d}x}=f(x)\mathrm{d}x$
（2）$\int {F}'(x)=F(x)+C$ 或 $\int \mathrm{d}F(x)=F(x)+C$
不定积分的性质 设$F(x)$是$f(x)$的一个原函数，$k$为非零常数，则有
（1）$\int kf(x)\mathrm{d}x=k\int f(x)\mathrm{d}x$;
（2）$\int [f(x) \pm g(x)]\mathrm{d}{x}=\int f(x)\mathrm{d}x \pm \int g(x)\mathrm{d}x$
基本积分公式 基本积分公式
$\tag{1} \int x^n dx = \frac{1}{n+1}x^{n+1},\hspace{1ex}n\neq -1$ $\tag{2} \int \frac{1}{x}dx = \ln |x| $
$\tag{3} \int u dv = uv - \int v du $ $\tag{4} \int \frac{1}{ax+b}dx = \frac{1}{a} \ln |ax + b|$</description></item><item><title>二阶常系数齐次线性微分方程</title><link>https://no-sky.github.io/2019/second-order-constant-coefficient-homogeneous-linear-differential-equation/</link><pubDate>Fri, 26 Apr 2019 17:08:07 +0800</pubDate><guid>https://no-sky.github.io/2019/second-order-constant-coefficient-homogeneous-linear-differential-equation/</guid><description>因为文章中包含大量数学公式，推荐使用电脑阅读本文章
标准形式 通解： ①写出相应的特征方程 $r^2+pr+q=0$
②求出特征根$r_1,r_2$
③写出通解：
**1)不同实根：**$r_1 \neq r_2, y=C_1e^{r_1x}+C_2e^{r_2x}$
**2)重根：**$r_1=r_2=r,y=C_1e^{rx}+C_2xe^{rx}$
**2)共轭复根：**$r_{1,2}=\alpha \pm \beta i, y=e^{\alpha x}(C_1\cos \beta x + C_2 \sin \beta x)$
例1：求微分方程${y}''+2{y}'+y=0$的通解
解：由题意得：$特征方程：r^2+2r+1=0 \\\\ \Rightarrow r_1=r_2=-1 \\\\ \therefore y=C_1e^{-x}+C_2xe^{-x}$
例2：求微分方程${y}''-4y=0$得通解
解：由题意得：$特征方程：r^2-4=0 \\\\ \Rightarrow r_1=2，r_2=-2 \\\\ \therefore y=C_1e^{2x}+C-2e^{-2x}$
例3： 求微分方程$2\frac{\mathrm{d}^2 y}{\mathrm{d} x^2}+4\frac{\mathrm{d} y}{\mathrm{d} x}+3y=0$的通解
解：由题意得：$特征方程：2r^2+4r+3=0 \\\\ \Rightarrow r=-1 \pm \frac{\sqrt{2}}{2}i \\\\ \therefore y=e^{-x}(C_1\cos \frac{\sqrt{2}}{2}x+C_2\sin \frac{\sqrt{2}}{2}x)$
已知通解，反求微分方程 ①找出特征根
②写出特征方程
③写出微分方程
例：写出通解为$y=C_1e^{-x}+C_2e^{3x}(C_1,C_2为任意常数)$的二阶线性常系数齐次微分方程
解：由题意得：$特征根：r_1=-1,r_2=3 \\\\ 特征方程：(r+1)(r-3)=0 \\\\ \Rightarrow r^2-2r-3=0 \\\\ 微分方程：{y}''-2{y}'-3y=0$</description></item><item><title>可降阶的高阶微分方程</title><link>https://no-sky.github.io/2019/reduced-order-higher-order-differential-equation/</link><pubDate>Fri, 26 Apr 2019 16:33:33 +0800</pubDate><guid>https://no-sky.github.io/2019/reduced-order-higher-order-differential-equation/</guid><description>因为文章中包含大量数学公式，推荐使用电脑阅读本文章
$y^{(n)}=f(x)$型 解法：作n次不定积分
例：求微分方程${y}'''=24x$通解
解：对原方程连续积分可得：${y}''=\int 24x\mathrm{d}x=12x^2+C_1 \\\\ {y}'=\int (12x^2+C_1)\mathrm{d}x=4x^3+C_1x+C_2 \\\\ y=\int (4x^3+C_1x+C_2)\mathrm{d}x=x^4+C_1\frac{x^2}{2}+C_2x+C3$
${y}''=f(x,{y}')$型 解法：令${y}'=P$，两边对x求导，${y}''=P$，然后代入原方程转化为一阶微分方程求解
例：求微分方程$x{y}''+{y}'=4x$的通解
解：$令{y}'=P,{y}''={P}' \\\\ 代入原方程得：x{P}'+P=4x \\\\ \Rightarrow {P}'+\frac{1}{x}P=4 \\\\ 可得：P=e^{-\int \frac{1}{x}\mathrm{d}x}(\int 4e^{\int \frac{1}{x}}\mathrm{d}x+C-1) \\\\ =e^{-lnx}(\int 4e^{lnx}\mathrm{d}x+C_1) \\\\ =\frac{1}{x}(\int 4x\mathrm{d}x+C_1) \\\\ =\frac{1}{x}(2x^2+C_1) \\\\ =2x+C_1\frac{1}{x} \\\\ \Rightarrow {y}'=2x+\frac{C_1}{x} \\\\ \Rightarrow y = \int (2x+\frac{C_1}{x})\mathrm{d}x \\\\ \Rightarrow y=x^2+C_1ln|x|+C-2$
${y}''=f(y,{y}')$型 解法：令${y}'=P$，两边对x求导，${y}''=\frac{\mathrm{d}P}{\mathrm{d}x}=\frac{\mathrm{d}P}{\mathrm{d}y}·\frac{\mathrm{d}y}{\mathrm{d}x}=P\frac{\mathrm{d}P}{\mathrm{d}y}$，然后代入原方程，转化为一阶微分方程求解
例：求微分方程$y{y}''-({y}')^2=0$的通解
解：$令{y}'=P,{y}''=P·\frac{\mathrm{d}P}{\mathrm{d}y} 代入原方程得：\\\\ y·P·\frac{\mathrm{d}P}{\mathrm{d}y}-P^2=0 \\\\ \Rightarrow y·\frac{\mathrm{d}P}{\mathrm{d}y}=P \\\\ \Rightarrow \frac{\mathrm{d}P}{P}=\frac{\mathrm{d}y}{y} \\\\ \Rightarrow \int \frac{\mathrm{d}P}{P}=\int \frac{\mathrm{d}y}{y} \\\\ \Rightarrow ln|P|=ln|y|+ln|C_1| \\\\ \Rightarrow P=C_1y \Rightarrow {y}'=C_1y \\\\ \Rightarrow \frac{\mathrm{d}y}{\mathrm{d}x}=C_1y \\\\ \Rightarrow \frac{\mathrm{d}y}{y}=C_1\mathrm{d}x \\\\ \Rightarrow \int \frac{\mathrm{d}y}{y}=\int C_1\mathrm{d}x \\\\ \Rightarrow ln|y|=C_1x+ln|C_2| \\\\ \Rightarrow y=C_2e^{C_1x}$</description></item><item><title>一阶线性微分方程</title><link>https://no-sky.github.io/2019/first-order-linear-differential-equation/</link><pubDate>Fri, 26 Apr 2019 16:17:39 +0800</pubDate><guid>https://no-sky.github.io/2019/first-order-linear-differential-equation/</guid><description>因为文章中包含大量数学公式，推荐使用电脑阅读本文章
标准形式 解法 ①化为标准形式
②套公式：
注：在此公式中，解不定积分时，不加绝对值，也不加任意常数C
例：解方程$x{y}'-y=x^3$
解：原方程可化为：${y}'-\frac{1}{x}y=x^2 \\\\ 由公式得：y=e^{-\int \frac{1}{x}\mathrm{d}x}(\int x^2e^{-\int \frac{1}{x}\mathrm{d}x}\mathrm{d}x+C) \\\\ =e^{lnx}(\int x^2e^{-lnx}\mathrm{d}x+C) \\\\ =x(\int x^2·\frac{1}{x}\mathrm{d}x+C) \\\\ =x(\frac{x^2}{2}+C) \\\\ =\frac{x^3}{2}+Cx \\\\ 即 y=\frac{x^3}{2}+Cx$</description></item><item><title>齐次方程</title><link>https://no-sky.github.io/2019/homogeneous-equation/</link><pubDate>Fri, 26 Apr 2019 15:56:15 +0800</pubDate><guid>https://no-sky.github.io/2019/homogeneous-equation/</guid><description>因为文章中包含大量数学公式，推荐使用电脑阅读本文章
解法 ①化为标准形式：${y}'=f(\frac{y}{x})$
②代入$u=\frac{y}{x}$，代入方程小区y
③化为x与u的可分离变量的微分方程，求解
例1：求$x{y}'-x\sin\frac{y}{x}-y=0$的通解。
解：原方程可化为：${y}'-\sin\frac{y}{x}=0 \Rightarrow {y}'=\sin\frac{y}{x}+\frac{y}{x} \\\\ 令\frac{y}{x}=u, y=xu, {y}'=u+xu \\\\ 代入原方程得：u+x{u}'=\sin u+u \\\\ \Rightarrow x\frac{\mathrm{d} u}{\mathrm{d} x} = \sin u \\\\ \Rightarrow \frac{\mathrm{d} u}{\sin u} = \frac{\mathrm{d} x}{x} \\\\ \Rightarrow \int \frac{1}{\sin u}\mathrm{d} u = \int \frac{1}{x}\mathrm{d} x \\\\ \Rightarrow ln|\csc u - \cot u| = ln|x| + ln|C| \\\\ \Rightarrow \csc u - \cot u = Cx \\\\ \Rightarrow \csc\frac{y}{x}-\cot\frac{y}{x}=Cx \\\\ 即原方程的通解是\csc\frac{y}{x}-\cot\frac{y}{x}=Cx$</description></item><item><title>常微分方程</title><link>https://no-sky.github.io/2019/ordinary-differential-equation/</link><pubDate>Fri, 26 Apr 2019 15:10:23 +0800</pubDate><guid>https://no-sky.github.io/2019/ordinary-differential-equation/</guid><description>因为文章中包含大量数学公式，推荐使用电脑阅读本文章
常微分方程的解 若$y=\varphi (x)$代入方程成为恒等式，则称$y=\varphi (x)$为方程的一个解。
通解 含有相互独立（不能合并，$y=C_1x+C_2x^2与y=C_1x+C_2x$）的任意常数，且任意常数的个数与方程的阶数相同的微分方程的解。
特解 不含任意常数的解。
例：已知微分方程${y}'+ay=e^x$的一个特解为$y=xe^x$,则a=__.
解：${y}'=e^x+x·e^x=(1+x)e^x \\\\ 代入微分方程得: (1+x)e^x+a·xe^x=e^x \\\\ \Rightarrow (1+x+ax)e^x=e^x \\\\ \Rightarrow a=-1$
可分离变量的微分方程 标准形式 解法 ①分离变量，化为标准形式
②两边同时积分
例1：求方程$\sec^2x+\tan y \mathrm{d} x + \sec^2 y \tan x \mathrm{d} y = 0$的通解
解：原方程可化为：$\sec^2x+\tan y \mathrm{d} x = - \sec^2 y \tan x \mathrm{d} y \\\\ \Rightarrow \frac{\sec^2 x}{\tan x} \mathrm{d} x = - \frac{\sec^2 y}{\tan y} \mathrm{d} x \\\\ \Rightarrow \int \frac{\sec^2 x}{\tan x} \mathrm{d} x = - \int \frac{\sec^2 y}{\tan y} \mathrm{d} x \\\\ \Rightarrow \int \frac{1}{\tan x} \mathrm{d} (\tan x) = - \int \frac{1}{\tan y} \mathrm{d} (\tan y) \\\\ \Rightarrow ln|\tan x| = - ln|(\tan y)| + ln|C| \\\\ \Rightarrow ln|\tan x| + ln|(\tan y)|= ln|C| \\\\ \Rightarrow ln|\tan x \tan y= ln|C| \\\\ \Rightarrow \tan x \tan y= C \\\\ 即原微分方程的通解是: \tan x \tan y= C$</description></item><item><title>空间曲面及其方程</title><link>https://no-sky.github.io/2019/space-surface-equation/</link><pubDate>Thu, 25 Apr 2019 17:32:01 +0800</pubDate><guid>https://no-sky.github.io/2019/space-surface-equation/</guid><description>球面 球心在点$M_0(x_0,y_0,z_0)$，半径为R的球面方程为：
**球面的一般方程：**$Ax^2+Ay^2+Az^2+Dx+Ey+Fz+G=0$
**平面方程的特点：**①三元二次方程；②缺交叉项③平方项系数相同
柱面 定义：直线（母线）沿着定曲线（准线）平行移动所产生的曲面
柱面方程的特点： 二元方程
旋转曲面 特点： 至少有2个变量的二次项系数相等
常见的二次曲面 **椭球面：**$\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1$
**单叶双曲面：**$\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=1$
**双叶双曲面：**$\frac{x^2}{a^2}-\frac{y^2}{b^2}-\frac{z^2}{c^2}=1$
**锥面：**$\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=0$
**椭圆抛物面：**$\frac{x^2}{2p}+\frac{y^2}{2q}=z(p,q同号)$
**双曲抛物线：**$\frac{x^2}{2p}-\frac{y^2}{2q}=z(p,q同号)$</description></item><item><title>空间直线方程</title><link>https://no-sky.github.io/2019/spatial-straight-line-equation/</link><pubDate>Thu, 25 Apr 2019 16:51:06 +0800</pubDate><guid>https://no-sky.github.io/2019/spatial-straight-line-equation/</guid><description>空间直线的方程 直线的一般方程 直线的点向式方程 已知有一点$M_0(x_0,y_0,z_0)$，方向向量$\vec{s}=(m,n,p)$，则有：
直线的参数方程 直线的两点式方程 空间中两直线的位置关系 $L_1: \frac{x-x_1}{m_1}=\frac{y-y_1}{n_1}=\frac{z-z_1}{p_1}$ $\vec{s_1}=(m_1,n_1,p_1)$
$L_2: \frac{x-x_2}{m_2}=\frac{y-y_2}{n_2}=\frac{z-z_2}{p_2}$ $\vec{s_2}=(m_2,n_2,p_2)$
①$\frac{m_1}{m_2}=\frac{n_1}{n_2}=\frac{p_1}{p_2} \Leftrightarrow \vec{s_1} // \vec{s_2} L_1 // L_2 $
②$m_1m_2 + n_1n_2 + p_1p_2 = 0 \Leftrightarrow \vec{s_1} \perp \vec{s_2} \Leftrightarrow L_1 \perp L_2$
③$\cos\theta = \cos(\vec{s_1},\vec{s_2}) = \frac{|\vec{s_1}·\vec{s_2}|}{|\vec{s_1}||\vec{s_2}|},\theta \in [0,\frac{\pi}{2}]$
直线与平面的位置关系 $L: \frac{x-x_0}{m}=\frac{y-y_0}{n}=\frac{z-z_0}{p}$ $\vec{s}=(m,n,p)$
$\pi: Ax+Bx+Cz+D=0$ $\vec{n}={A,B,C}$
①$\frac{A}{m}=\frac{B}{n}=\frac{C}{p} \Leftrightarrow \vec{n} // \vec{s} \Leftrightarrow L \perp \pi$
②$Am+Bn+Cp=0 \Leftrightarrow \vec{n} \perp \vec{s} \Leftrightarrow \pi$
​ 将直线上已知点的坐标$(x_0,y_0,z_0)$代入平面的方程中，若恒成立，则直线在平面上，否则，平行。
③$\sin\phi = \cos(\vec{s},\vec{n}) = \frac{|\vec{s}·\vec{n}|}{|\vec{s}|·|\vec{n}|},\phi \in [0,\frac{\pi}{2}]$</description></item><item><title>空间中两平面的位置关系</title><link>https://no-sky.github.io/2019/positional-relationship-between-two-planes/</link><pubDate>Thu, 25 Apr 2019 15:57:33 +0800</pubDate><guid>https://no-sky.github.io/2019/positional-relationship-between-two-planes/</guid><description>两平面的位置关系 平面$\pi_{1}$： $A_{1}x + B_{1}y + C_{1}z + D_{1} = 0 \\\\ \vec{n_{1}} = (A_{1}, B_{1}, C_{1}) $
平面$\pi_{2}$: $A_{2}x + B_{2}y + C_{2}z + D_{2} = 0 \\\\ \vec{n_{2}} = (A_{2}, B_{2}, C_{2})$
① $\frac{A_{1}}{A_{2}} = \frac{B_{1}}{B_{2}} = \frac{C_{1}}{C_{2}} \Leftrightarrow \vec{n_{1}} // \vec{n_{2}} \Leftrightarrow \pi_{1} // \pi_{2} $
​ 若$\frac{A_{1}}{A_{2}} = \frac{B_{1}}{B_{2}} = \frac{C_{1}}{C_{2}} = \frac{D_{1}}{D_{2}} ,\pi_{1}与\pi_{2}$重合
​ 若$\frac{A_{1}}{A_{2}} = \frac{B_{1}}{B_{2}} = \frac{C_{1}}{C_{2}} \neq \frac{D_{1}}{D_{2}} ,\pi_{1}与\pi_{2}$平行不重合
②$A_{1}A_{2} + B_{1}B_{2} + C_{1}C_{2} = 0 \Leftrightarrow \vec{n_{1}} \perp \vec{n_{2}} \Leftrightarrow \pi_{1} \perp \pi_{2}$</description></item><item><title>向量的线性运算</title><link>https://no-sky.github.io/2019/vector-and-linear-operations_2/</link><pubDate>Tue, 23 Apr 2019 14:20:06 +0800</pubDate><guid>https://no-sky.github.io/2019/vector-and-linear-operations_2/</guid><description>加法 **定义1：**设$\vec{a} = (a_1, a_2)$，$\vec{b} = (b_1, b_2)$是二维空间向量$R^2$中的两个向量，定义它们的加法为
定义1：设$\vec{a} = (a_1, a_2, a_3)$，$\vec{b} = (b_1, b_2, b_3)$是三维向量空间$R^3$中的两个向量，定义它们的加法为：
​ 一般的，设$\vec{a} = (a_1,a_2,···,a_n),\vec{b} = (b_1,b_2,···,b_n)$是n维向量空间$R^n$中的两个向量，定义它们的加法为：
运算规律：
​ 数乘 定义3：设$\vec{a} = (a_1, a_2)$，$\vec{b} = (b_1, b_2)$是二维空间向量$R^2$中的两个向量，$\lambda$是实数，定义$\lambda$与$\vec{a}$的数乘为：
设$\vec{a}$是非零向量，$\lambda$是非零实数，记$\vec{b} = \lambda \vec{a}$，则有
定义4：设$\vec{a} = (a_1, a_2, a_3)$，$\vec{b} = (b_1, b_2, b_3)$是三维空间向量$R^3$中的两个向量，$\lambda$是实数，定义$\lambda$与$\vec{a}$的数乘为：
一般的，对于n维向量与实数的数乘以此类推。
减法 利用向量的加法与数乘运算，得出向量的减法
单位向量 表示 设$e_a$表示非零向量$\vec{a}$同向的单位向量，则有
称$e_a$为$\vec{a}$的单位方向向量
对于三维向量$\vec{a}$，有
向量平行等价说法： （1）$\vec{a} // \vec{b}$
（2）存在实数$\lambda$，使得$\vec{b} = \lambda \vec{a}$
（3）$\vec{a}与\vec{b}$对应分量成比例
（4）存在不全为零的常数$k_1,k_2$，使得$k_1\vec{a} + k_2\vec{b} = 0$
例：设$\vec{a} = (2,1),\vec{b} = (-3,1)$，求$\vec{c} = \vec{a}+2\vec{b}$的单位向量</description></item><item><title>向量的基本概念</title><link>https://no-sky.github.io/2019/vector-and-linear-operations_1/</link><pubDate>Mon, 22 Apr 2019 17:03:01 +0800</pubDate><guid>https://no-sky.github.io/2019/vector-and-linear-operations_1/</guid><description>向量的基本概念 向量：既有大小，又有方向的量。
数量：只有大小，没有方向的量。
向量表示法：用一条带箭头的线段（即有向线段）表示
如：$\overrightarrow{AB}$ A为起点，B为终点
还可以用粗体字母或带箭头的字母表示向量
例如：v，a，F 或 $\vec{v}$，$\vec{a}$， $\vec{F}$
对于自由向量，如果向量$\vec{a}$与$\vec{b}$大小相等且方向相同，则称$\vec{a}$与$\vec{b}$相等，记作 $\vec{a}$ = $\vec{b}$
向量的模：向量的大小。表示方法：$|\overrightarrow{AB}|$或a或$|\vec{a}|$
单位向量：模等于1的向量。
零向量：模为零的向量。记作0或$\vec{0}$. 零向量的起点与终点重合，他的方向可以看作是任意的。
向量平行：两个非零向量如果它们的方向相同或者相反，就称这两个向量平行。如果向量$\vec{a}$和$\vec{b}$平行，记作$\vec{a}//\vec{b}$。零向量与任何向量平行。
负向量：与$\vec{a}$的模相同，但方向相反的向量，记作$-\vec{a}$
向量共线：即两向量平行。
向量共面：向量经平移可移到同一平面上。
空间向量的坐标表示 前置： 平面上点P(x, y) $\rightleftharpoons $ 向量$\overrightarrow{OP}$（称为径向量）
对平面上的两点$A(x_1, y_1)$，$B(x_2, y_2)$，有向线段$\overrightarrow{AB}$的坐标表示
向量$\overrightarrow{AB}$与x轴和y轴的正向夹角$\alpha $和$\beta$称为方向角
空间向量的坐标表示 其中$x_2 - x-1, y_2 - y1, z_2 - z_1$分别称为$|\overrightarrow{AB}|$的x, y, z轴方向上的分量。
方向角：$0 \leq \alpha , \beta, \gamma \leq \pi$
方向余弦：$\cos\alpha , \cos\beta, \cos\gamma$
空间中的向量也由他的分量唯一确定。因此一个空间的向量通常表示为
并且称它为一个三位向量，且有：
$|\vec{a}| = \sqrt{a_1^2 + a_2^2 + a_3^2}$ $\cos\alpha = \frac{a_1}{\sqrt{a_1^2 + a_2^2 + a_3^2}}$</description></item><item><title>空间中两点的距离</title><link>https://no-sky.github.io/2019/distance-between-two-points/</link><pubDate>Mon, 22 Apr 2019 16:26:42 +0800</pubDate><guid>https://no-sky.github.io/2019/distance-between-two-points/</guid><description>前置：数轴上两点的距离 前置：平面上两点的距离 空间中两点的距离 假设空间中两点，$M_1$为$(x_1, y_1, z_1)$`,$M_2$为$(x_2, y_2, z_2)$`，则距离公示为：
特别的，点M(x, y, z)到原点O(0, 0, 0)的距离为：
例题1 在z轴上求两点A(3，1，-4)和B(5，3，2)等距离的点。
解：设z轴上点为M(0, 0, z)，由题意|MA| = |MB|，即
​ $$\sqrt{(3-0)^2 + (1-0)^2 + (-4 - z)^2} = \sqrt{(5-0)^2 + (3-0)^2 + (2-z)^2}$$解得，z = 1，所求点位为M(0,0,1)。</description></item><item><title>空间直角坐标系</title><link>https://no-sky.github.io/2019/spatial-rectangular-coordinate-system/</link><pubDate>Mon, 22 Apr 2019 15:30:00 +0800</pubDate><guid>https://no-sky.github.io/2019/spatial-rectangular-coordinate-system/</guid><description>前言：空间直角坐标系
过空间中一定点O，作三条互相垂直的数轴构成的坐标系称为空间直角坐标系。
坐标原点：O点 坐标轴：x轴，y轴，z轴 右手坐标系：用右手握住z轴，使大拇指的方向指向Z轴的正向，其他手指的方向就是从x轴的正向到y轴的正向 坐标面：xOy平面，yOz平面，xOz平面， 卦限：八个卦限 空间中点的坐标
点M &amp;lt;————&amp;gt; 有序三元数组(x, y, z)
有序三元数组(x, y, z)称为点M的坐标
x - 横坐标；y - 纵坐标；z - 竖坐标
点M也记为：M(x, y, z)
所有的有序三元数组的集合记作：
$R^3 = \{(x,y,z)|x\epsilon R,y\epsilon R,z\epsilon R\}$
坐标轴：
x轴 $\leftrightarrow \begin{cases} y= 0 \\\\ z= 0 \end{cases}$ y轴 $\leftrightarrow \begin{cases} z= 0 \\\\ x= 0 \end{cases}$ z轴 $\leftrightarrow \begin{cases} x= 0 \\\\ y= 0 \end{cases}$
坐标面：
xOy面：$\leftrightarrow$ z = 0 yOz面：$\leftrightarrow$ x = 0 zOx面：$\leftrightarrow$ y = 0</description></item><item><title>SpringBoot Jpa @OneByOne双向查询报栈溢出原因</title><link>https://no-sky.github.io/2018/springboot-jpa-onebyone%E5%8F%8C%E5%90%91%E6%9F%A5%E8%AF%A2%E6%8A%A5%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E5%9B%A0/</link><pubDate>Sun, 14 Oct 2018 22:59:46 +0000</pubDate><guid>https://no-sky.github.io/2018/springboot-jpa-onebyone%E5%8F%8C%E5%90%91%E6%9F%A5%E8%AF%A2%E6%8A%A5%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E5%9B%A0/</guid><description>示例：
@Data @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer uid; /**用户名*/ private String username; /**用户密码*/ private String password; /**注册时间*/ private Timestamp regTime; /**性别*/ private Boolean sex; @OneToOne(cascade = CascadeType.ALL) @JoinColumn(name = &amp;#34;weixin&amp;#34;) private WXToken wxToken; } @Data @Entity public class WXToken { /**微信号*/ @Id private String weixin; /**微信token授权*/ private String token; /**授权开始时间*/ private Timestamp startTime; /**授权过期时间*/ private Timestamp expireTime; @OneToOne(mappedBy = &amp;#34;wxToken&amp;#34;, cascade = CascadeType.ALL) private User user; } 报错：</description></item><item><title>Maven与eclipse</title><link>https://no-sky.github.io/2018/maven%E4%B8%8Eeclipse/</link><pubDate>Wed, 04 Apr 2018 22:23:49 +0000</pubDate><guid>https://no-sky.github.io/2018/maven%E4%B8%8Eeclipse/</guid><description>下载与安装 1、前往 https://maven.apache.org/download.cgi 下载最新版的Maven程序：
2、将文件解压到F:\Program Files\Apache\apache-maven-3.5.3（此处是我的安装路径）目录下: ​ 3、新建环境变量MAVEN_HOME，赋值F:\Program Files\Apache\apache-maven-3.5.3 ​ 4、编辑环境变量Path，追加%MAVEN_HOME%\bin\;
5、至此，maven已经完成了安装，我们可以通过DOS命令检查一下我们是否安装成功 ​ ​ mvn -v
配置Maven本地仓库 1、在F:\Program Files\Apache\目录下新建maven-repository文件夹，该目录用作maven的本地库。
2、打开F:\Program Files\Apache\apache-maven-3.5.3\conf\settings.xml文件，查找下面这行代码： ​ ​ /path/to/local/repolocalRepository节点默认是被注释掉的，需要把它移到注释之外，然后将localRepository节点的值改为我们在3.1中创建的目录F:\Program Files\Apache\maven-repository
3、localRepository节点用于配置本地仓库，本地仓库其实起到了一个缓存的作用，它的默认地址是 C:\Users\用户名.m2。
当我们从maven中获取jar包的时候，maven首先会在本地仓库中查找，如果本地仓库有则返回；如果没有则从远程仓库中获取包，并在本地库中保存。
此外，我们在maven项目中运行mvn install，项目将会自动打包并安装到本地仓库中。
4、运行一下DOS命令
mvn help:system 如果前面的配置成功，那么F:\Program Files\Apache\maven-repository会出现一些文件。
配置Eclipse的Maven环境 1、Eclipse Oxygen，打开Window-&amp;gt;Preferences-&amp;gt;Maven-&amp;gt;Installations，右侧点击Add。
2、设置maven的安装目录，然后Finish
3、 选中刚刚添加的maven，并Apply。
4、 打开Window-&amp;gt;Preferences-&amp;gt;Maven-&amp;gt;User Settings，配置如下并Apply：
至此，Maven的安装和配置全部结束。</description></item><item><title>Sublime Text3常用插件</title><link>https://no-sky.github.io/2018/sublime-text3%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</link><pubDate>Mon, 19 Mar 2018 17:47:28 +0000</pubDate><guid>https://no-sky.github.io/2018/sublime-text3%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</guid><description>&lt;h1 id="chineselocalizations">ChineseLocalizations&lt;/h1>
&lt;p>&lt;strong>一种让Sublime汉化的插件&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://github.com/No-Sky/storage/raw/master/images/SublimeText/ChineseLocalizations.png" alt="">&lt;/p></description></item><item><title>Next | Hexo主题的多种样式配置</title><link>https://no-sky.github.io/2018/next-hexo%E4%B8%BB%E9%A2%98%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%A0%B7%E5%BC%8F%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 17 Mar 2018 11:58:50 +0000</pubDate><guid>https://no-sky.github.io/2018/next-hexo%E4%B8%BB%E9%A2%98%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%A0%B7%E5%BC%8F%E9%85%8D%E7%BD%AE/</guid><description>添加404界面 在source文件夹新建404.html，内容如下：
--- layout: false title: &amp;#34;404&amp;#34; --- &amp;lt;!DOCTYPE HTML&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;404 - No-Sky&amp;#39;blog&amp;lt;/title&amp;gt; &amp;lt;meta name=&amp;#34;description&amp;#34; content=&amp;#34;404错误，页面不存在！&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;content-type&amp;#34; content=&amp;#34;text/html;charset=utf-8;&amp;#34;/&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge,chrome=1&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;robots&amp;#34; content=&amp;#34;all&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;robots&amp;#34; content=&amp;#34;index,follow&amp;#34;/&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;http://qzonestyle.gtimg.cn/qzone_v6/lostchild/search_children.js&amp;#34; charset=&amp;#34;utf-8&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 添加本地搜索功能 首先安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：
$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置：
search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： （在next主题的最新版已经有了这个配置，所以只要找local_search，把false改成true）
# Local search local_search: enable: true 修改标签样式 修改文章底部的那个带#号的标签 实现效果图</description></item><item><title>Git连接github超时问题解决方案</title><link>https://no-sky.github.io/2018/git%E8%BF%9E%E6%8E%A5github%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link><pubDate>Sat, 17 Mar 2018 11:24:34 +0000</pubDate><guid>https://no-sky.github.io/2018/git%E8%BF%9E%E6%8E%A5github%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid><description>&lt;p>因为电脑重新装了几次了导致 Git连接github时出现 了超时问题 ，如下：
&lt;code>ssh: connect to host github.com port 22: Connection timed out #使用ssh连接github时,出现timeout&lt;/code>
（Windows下）解决方案也很简单，修改ssh的配置文件。关于修改配置，存在两种解决方法，一种是C:\Program Files\Git\etc\ssh/ssh_config（你自己安装git的文件夹下面找）中修改全局配置，一种是在用户主目录下.ssh/中添加配置文件，这里我选择的后者（前者也可以解决问题，其实都可以）&lt;/p></description></item><item><title>Mybatis-generator之mybatis的快速使用</title><link>https://no-sky.github.io/2018/mybatis-generator%E4%B9%8Bmybatis%E7%9A%84%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/</link><pubDate>Sun, 04 Feb 2018 21:17:05 +0000</pubDate><guid>https://no-sky.github.io/2018/mybatis-generator%E4%B9%8Bmybatis%E7%9A%84%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/</guid><description>mybatis-generator插件自动生成单表的类和映射文件 1、 下载mybatis-generrator插件包
mybatis-generator-core-1.3.2
目录结构：
docs //说明文档文件夹 lib //jar包文件夹 LICENSE NOTICE README.txt 2、 配置mybatis-generator插件
在lib文件夹下有一个generatorConfig.xml文件用NotePad++打开：
&amp;lt;generatorConfiguration&amp;gt; &amp;lt;!--数据库驱动--&amp;gt; &amp;lt;classPathEntry location=&amp;#34;mysql-connector-java-5.1.25-bin.jar&amp;#34;/&amp;gt; &amp;lt;context id=&amp;#34;DB2Tables&amp;#34; targetRuntime=&amp;#34;MyBatis3&amp;#34;&amp;gt; &amp;lt;commentGenerator&amp;gt; &amp;lt;property name=&amp;#34;suppressDate&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt; &amp;lt;!--是否去除自动生成的注释 true：是 ： false:否 --&amp;gt; &amp;lt;property name=&amp;#34;suppressAllComments&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt; &amp;lt;/commentGenerator&amp;gt; &amp;lt;!--数据库链接URL，用户名、密码 --&amp;gt; &amp;lt;jdbcConnection driverClass=&amp;#34;com.mysql.jdbc.Driver&amp;#34; connectionURL=&amp;#34;jdbc:mysql://127.0.0.1:3306/db_novel&amp;#34; userId=&amp;#34;root&amp;#34; password=&amp;#34;123456&amp;#34;&amp;gt; &amp;lt;/jdbcConnection&amp;gt; &amp;lt;javaTypeResolver&amp;gt; &amp;lt;property name=&amp;#34;forceBigDecimals&amp;#34; value=&amp;#34;false&amp;#34;/&amp;gt; &amp;lt;/javaTypeResolver&amp;gt; &amp;lt;!--生成模型的包名和位置--&amp;gt; &amp;lt;javaModelGenerator targetPackage=&amp;#34;novel.spider.entitys&amp;#34; targetProject=&amp;#34;src&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;enableSubPackages&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;trimStrings&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt; &amp;lt;/javaModelGenerator&amp;gt; &amp;lt;!--生成映射文件的包名和位置--&amp;gt; &amp;lt;sqlMapGenerator targetPackage=&amp;#34;mapper&amp;#34; targetProject=&amp;#34;src&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;enableSubPackages&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt; &amp;lt;/sqlMapGenerator&amp;gt; &amp;lt;!--生成DAO的包名和位置--&amp;gt; &amp;lt;javaClientGenerator type=&amp;#34;XMLMAPPER&amp;#34; targetPackage=&amp;#34;novel.</description></item><item><title>Mybatis之多表查询</title><link>https://no-sky.github.io/2018/mybatis%E4%B9%8B%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</link><pubDate>Sat, 03 Feb 2018 21:11:27 +0000</pubDate><guid>https://no-sky.github.io/2018/mybatis%E4%B9%8B%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>** 一对一 **&lt;/p>
&lt;ol>
&lt;li>创建表和数据：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sql" data-lang="sql"> &lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> teacher(
t_id INT &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> AUTO_INCREMENT,
t_name VARCHAR(&lt;span style="color:#ae81ff">20&lt;/span>)
);
&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span>(
c_id INT &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> AUTO_INCREMENT,
c_name VARCHAR(&lt;span style="color:#ae81ff">20&lt;/span>),
teacher_id INT
);
&lt;span style="color:#66d9ef">ALTER&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#66d9ef">ADD&lt;/span> &lt;span style="color:#66d9ef">CONSTRAINT&lt;/span> fk_teacher_id &lt;span style="color:#66d9ef">FOREIGN&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> (teacher_id) &lt;span style="color:#66d9ef">REFERENCES&lt;/span> teacher(t_id);
&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> teacher(t_name) &lt;span style="color:#66d9ef">VALUES&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#e6db74">LS1&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>);
&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> teacher(t_name) &lt;span style="color:#66d9ef">VALUES&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#e6db74">LS2&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>);
&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span>(c_name, teacher_id) &lt;span style="color:#66d9ef">VALUES&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#e6db74">bj_a&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span>(c_name, teacher_id) &lt;span style="color:#66d9ef">VALUES&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#e6db74">bj_b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Mybatis之优化XML配置</title><link>https://no-sky.github.io/2018/mybatis%E4%B9%8B%E4%BC%98%E5%8C%96xml%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 03 Feb 2018 21:04:38 +0000</pubDate><guid>https://no-sky.github.io/2018/mybatis%E4%B9%8B%E4%BC%98%E5%8C%96xml%E9%85%8D%E7%BD%AE/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>** 数据库配置优化 **&lt;/p>
&lt;p>原：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-XML" data-lang="XML"> &lt;span style="color:#f92672">&amp;lt;environments&lt;/span> &lt;span style="color:#a6e22e">default=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;development&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;environment&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;development&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;transactionManager&lt;/span> &lt;span style="color:#a6e22e">type=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;JDBC&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dataSource&lt;/span> &lt;span style="color:#a6e22e">type=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;POOLED&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;driver&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;oracle.jdbc.driver.OracleDriver&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;url&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;jdbc:oracle:thin:@127.0.0.1:1521:ORCL&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;username&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;scott&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;password&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;tiger&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dataSource&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/environment&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/environments&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Mybatis之CRUD操作</title><link>https://no-sky.github.io/2018/mybatis%E4%B9%8Bcrud%E6%93%8D%E4%BD%9C/</link><pubDate>Sat, 03 Feb 2018 21:00:13 +0000</pubDate><guid>https://no-sky.github.io/2018/mybatis%E4%B9%8Bcrud%E6%93%8D%E4%BD%9C/</guid><description>用xml配置的方式
1、定义sql映射的xml文件 如：
id: 是sql语句在xml文件的位置 parameterType: 需要传递参数的类型 resultType: sql语句执行后返回的类型 &amp;lt;select id=&amp;#34;getEmpByName&amp;#34; parameterType=&amp;#34;string&amp;#34; reaultType=&amp;#34;com.model.Emp&amp;#34; &amp;gt; select * from emp where ename = #{ename}; &amp;lt;/select&amp;gt; &amp;lt;insert id=&amp;#34;insertEmp&amp;#34; parameterType=&amp;#34;com.model.Emp&amp;#34; resultType=&amp;#34;int&amp;#34;&amp;gt; insert into emp values (#{empno,#{ename},#{job},#{mgr},#{hiredate},#{sql},#{comm},#{deptno}) &amp;lt;/insert&amp;gt; &amp;lt;delete id=&amp;#34;deleteByNo&amp;#34; parameterType=&amp;#34;int&amp;#34;&amp;gt; delete from emp where empno = #{empno} &amp;lt;delete&amp;gt; &amp;lt;update id=&amp;#34;updateByNo&amp;#34; parameterType=&amp;#34;com.model.Emp&amp;#34; resultType=&amp;#34;int&amp;#34;&amp;gt; update emp set ename=#{ename},job=#{job},... where empno=#{empno} &amp;lt;/update&amp;gt; 2、在mybatis配置文件中注册实体对应的SQL映射
&amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&amp;#34;com/mapper/EmpMapper.xml&amp;#34;/&amp;gt; &amp;lt;/mappers&amp;gt; 3、在dao中使用
public Emp getEmpByName(String ename) { 创建SessionFactory的代码省略 SqlSession session = sessionFactory.</description></item><item><title>Mybatis初识</title><link>https://no-sky.github.io/2018/mybatis%E5%88%9D%E8%AF%86/</link><pubDate>Sat, 03 Feb 2018 20:55:54 +0000</pubDate><guid>https://no-sky.github.io/2018/mybatis%E5%88%9D%E8%AF%86/</guid><description>Mybatis初识 * ​ MyBatis是支持普通SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis消除 ​ 了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索。MyBatis可以使用简单的 ​ XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的 ​ Java对象）映射成数据库中的记录。 * Mybatis简单使用
1、引入jar包 * ​ mybatis-3.1.1.jar ​ log4j-1.2.16.jar ​ ojdbc5.jar * 2、创建数据库和表
为了更简单的创建一个实例，我使用了Oracle的scoot账户， 直接使用emp表作为示例
3、 在示例项目下添加mybatis配置文件 mybatis-conf.xml (命名随意)
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE configuration PUBLIC &amp;#34;-//mybatis.org//DTD Config 3.0//EN&amp;#34; &amp;#34;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;#34;&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;environments default=&amp;#34;development&amp;#34;&amp;gt; &amp;lt;environment id=&amp;#34;development&amp;#34;&amp;gt; &amp;lt;transactionManager type=&amp;#34;JDBC&amp;#34; /&amp;gt; &amp;lt;dataSource type=&amp;#34;POOLED&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;driver&amp;#34; value=&amp;#34;oracle.jdbc.driver.OracleDriver&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;url&amp;#34; value=&amp;#34;jdbc:oracle:thin:@127.0.0.1:1521:ORCL&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;scott&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;tiger&amp;#34; /&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt; &amp;lt;/environments&amp;gt; &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&amp;#34;com/mapper/EmpMapper.</description></item><item><title>用Java生成二维码</title><link>https://no-sky.github.io/2018/%E7%94%A8java%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/</link><pubDate>Sat, 20 Jan 2018 20:50:43 +0000</pubDate><guid>https://no-sky.github.io/2018/%E7%94%A8java%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/</guid><description>java开发二维码的流程
1、导入核心jar包，在这里使用Google的zxing.jar，还有一个是日本开发qrcode就不用了。
core-3.1.0.jar 2、编写二维码核心类
public static void zxingImg(String content,HttpServletResponse response) throws IOException{ int width2 = 200; //图片高度和宽度 int height2 = 200; //二维码的图片格式 String format = &amp;#34;gif&amp;#34;; Hashtable hints = new Hashtable(); //内容所使用编码 hints.put(EncodeHintType.CHARACTER_SET, &amp;#34;UTF-8&amp;#34;); try { BitMatrix bitMatrix = new MultiFormatWriter().encode(content,BarcodeFormat.QR_CODE, width2, height2, hints); int width = bitMatrix.getWidth(); int height = bitMatrix.getHeight(); BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); for (int x = 0; x &amp;lt; width; x++) { for (int y = 0; y &amp;lt; height; y++) { image.</description></item><item><title>Oracle笔记 （十四）</title><link>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%9B%9B/</link><pubDate>Tue, 12 Dec 2017 19:38:50 +0000</pubDate><guid>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%9B%9B/</guid><description>游标、存储过程 ##一、游标参数的传递 例：
SET SERVEROUTPUT ON DECLARE V_empno NUMBER(5); V_ename VARCHAR2(10); CURSOR emp_cursor(p_deptno NUMBER,p_job VARCHAR2) IS SELECT empno,ename FROM emp WHERE deptno = p_deptno AND job = p_job; BEGIN OPEN emp_cursor(10, &amp;#39;CLERK&amp;#39;); LOOP FETCH emp_cursor INTO v_empno,v_ename; EXIT WHEN emp_cursor%NOTFOUND; DBMS_OUTPUT.PUT_LINE(v_empno||&amp;#39;,&amp;#39;||v_ename); END LOOP; END; 二、异常处理 错误处理的语法如下：
EXCEPTION WHEN 错误1[OR 错误2] THEN 语句序列1; WHEN 错误3[OR 错误4] THEN 语句序列2; ... WHEN OTHERS 语句序列n; END; 例：
SET SERVEROUTPUT ON DECLARE v_name VARCHAR2(10); BEGIN SELECT ename INTO v_name FROM emp WHERE empno = 1234; DBMS_OUTPUT.</description></item><item><title>Oracle笔记 （十三）</title><link>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%89/</link><pubDate>Tue, 05 Dec 2017 19:11:04 +0000</pubDate><guid>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%89/</guid><description>PL/SQL空值语句、游标 一、IF语句 1、IF-THEN-END IF形式 2、IF-THEN-ELSE-END IF形式 3．IF-THEN-ELSIF-ELSE-END IF形式 ##二、CASE语句
1．基本CASE结构 2.搜索CASE结构 三、循环 1．基本LOOP循环 2.FOR LOOP循环 FOR循环是固定次数循环，格式如下：
注：循环控制变量是隐含定义的，不需要声明。 ​ 下限和上限用于指明循环次数。正常情况下循环控制变量的取值由下限到上限递增，REVERSE关键字表示循环控制变量的取值由上限到下限递减。
3．WHILE LOOP循环 四、游标 1、概念 游标是SQL的一个内存工作区，由系统或用户以变量的形式定义。游标的作用就是用于临时存储从数据库中提取的数据块。在某些情况下，需要把数据从存放在磁盘的表中调到计算机内存中进行处理，最后将处理结果显示出来或最终写回数据库。这样数据处理的速度才会提高，否则频繁的磁盘数据交换会降低效率。
游标有两种类型：显式游标和隐式游标。
在前述程序中用到的SELECT&amp;hellip;INTO&amp;hellip;查询语句，一次只能从数据库中提取一行数据，系统都会使用一个隐式游标。
显式游标对应一个返回结果为多行多列的SELECT语句。
游标一旦打开，数据就从数据库中传送到游标变量中，然后应用程序再从游标变量中分解出需要的数据，并进行处理。
2、隐式游标属性 隐式游标的属性 返回值类型 意义 SQL%ROWCOUNT 整型 代表DML语句成功执行的数据行数 SQL%FOUND 布尔型 值为TRUE代表插入、删除、更新或单行查询操作成功 SQL%NOTFOUND 布尔型 与SQL%FOUND属性返回值相反 SQL%ISOPEN 布尔型 DML执行过程中为真，结束后为假 如：使用隐式游标的属性，判断对雇员工资的修改是否成功。
SET SERVEROUTPUT ON BEGIN UPDATE emp SET sal=sal+100 WHERE empno=1234; IF SQL%FOUND THEN DBMS_OUTPUT.</description></item><item><title>Oracle笔记 （十二）</title><link>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%BA%8C/</link><pubDate>Tue, 05 Dec 2017 18:40:55 +0000</pubDate><guid>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%BA%8C/</guid><description>索引、同义词、数据库链接、PL/SQL语句 一、索引 索引(INDEX)是为了加快数据的查找而创建的数据库对象，特别是对大表，索引可以有效地提高查找速度，也可以保证数据的惟一性
创建索引一般要掌握以下原则：只有较大的表才有必要建立索引，表的记录应该大于50条，查询数据小于总行数的2%～4%。虽然可以为表创建多个索引，但是无助于查询的索引不但不会提高效率，还会增加系统开销。因为当执行DML操作时，索引也要跟着更新，这时索引可能会降低系统的性能。
创建索引：
CREATE INDEX 索引名 ON 表名(列名); 删除索引：
DROP INDEX 索引名； 二、同义词 ** 同义词(SYNONYM)是为模式对象起的别名，可以为表、视图、序列、过程、函数和包等数据库模式对象创建同义词。**
创建私有同义词：
CREATE SYNONYM BOOK FOR 图书； 创建公有同义词(先要获得创建公有同义词的权限)：
CREATE PUBLIC SYNONYM BOOK FOR SCOTT.图书； 删除同义词：
DROP SYNONYM 同义词名； 三、数据库链接 ** 数据库链接(DATABASE LINK)是在分布式环境下，为了访问远程数据库而创建的数据通信链路。**
格式：
CREATE DATABASE LINK 链接名 CONNECT TO 账户 IDENTIFIED BY 口令 USING 服务名; 数据库链接一旦建立并测试成功，就可以使用以下形式来访问远程用户的表。
表名@数据库链接名 四、PL/sql 1、块结构和基本语法要求 块中各部分的作用解释如下：
(1) DECLARE：声明部分标志。 (2) BEGIN：可执行部分标志。 (3) EXCEPTION：异常处理部分标志。 (4) END；：程序结束标志。 2、输出 第一种形式：
DBMS_OUTPUT.PUT(字符串表达式)； 第二种形式：
DBMS_OUTPUT.PUT_LINE(字符串表达式)； 第三种形式：</description></item><item><title>java中的foreach与js中的for in的区别</title><link>https://no-sky.github.io/2017/java%E4%B8%AD%E7%9A%84foreach%E4%B8%8Ejs%E4%B8%AD%E7%9A%84for-in%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Tue, 05 Dec 2017 12:18:47 +0000</pubDate><guid>https://no-sky.github.io/2017/java%E4%B8%AD%E7%9A%84foreach%E4%B8%8Ejs%E4%B8%AD%E7%9A%84for-in%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>js里的for in循环定义如下：
代码如下:
for(var variable in obj) { ... } obj可以是一个普通的js对象或者一个数组。如果obj是js对象，那么variable在遍历中得到的是对象的属性的名字，而不是属性对应的值。如果obj是数组，那么variable在遍历中得到的是数组的下标。
遍历对象实验：
代码如下:
var v = {}; v.field1 = &amp;#34;a&amp;#34;; v.field2 = &amp;#34;b&amp;#34;; for(var v in v) { console.log(v); } 控制台下输出：
field1 field2 遍历数组实验：
代码如下:
var mycars = new Array() mycars[0] = &amp;#34;Saab&amp;#34; mycars[1] = &amp;#34;Volvo&amp;#34; mycars[2] = &amp;#34;BMW&amp;#34; for (var x in mycars){ console.log(x); } 控制台输出：
0 1 2 拿java的foreach循环来做对比，有两大差别。首先java的foreach循环不会去枚举一个java对象的属性。其次，java的foreach循环枚举一个数组或者任何实现了Iterable接口的对象的时候，for(Object o : list), 对象o得到的是list一个元素，而非在列表中的下标。
java的遍历代码就不贴出来了。经常写后台代码，foreach循环很熟悉。写前台js代码的时候，难免会套用java的语法，所以第一次用js的for in循环的时候犯错了。</description></item><item><title>Oracle笔记 （十一）</title><link>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%80/</link><pubDate>Sat, 02 Dec 2017 17:43:26 +0000</pubDate><guid>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%80/</guid><description>分区、视图 一、分区表 在某些场合会使用非常大的表，比如人口信息统计表。如果一个表很大，就会降低查询的速度，并增加管理的难度。一旦发生磁盘损坏，可能整个表的数据就会丢失，恢复比较困难。根据这一情况，可以创建分区表，把一个大表分成几个区(小段)，对数据的操作和管理都可以针对分区进行，这样就可以提高数据库的运行效率。分区可以存在于不同的表空间上，提高了数据的可用性。例：创建和使用分区表。 ​ 如：创建按成绩分区的考生表，共分为3个区：
步骤3：检查A区中的考生：
SELECT * FROM 考生 PARTITION(A); 步骤4：检查全部的考生：
SELECT * FROM 考生; 二、视图 1、视图的概念 视图不同于表，视图本身不包含任何数据。而视图只是一种定义，对应一个查询语句。视图的数据都来自于某些表，这些表被称为基表。 视图可以在表能够使用的任何地方使用，但在对视图的操作上同表相比有些限制，特别是插入和修改操作。对视图的操作将传递到基表，所以在表上定义的约束条件和触发器在视图上将同样起作用。2、视图的创建
2、格式： create [or replace] view 视图名 as select 语句; 例：创建图书作者视图：
CREATE VIEW 图书作者(书名,作者) AS SELECT 图书名称,作者 FROM 图书; 查询视图全部内容
SELECT * FROM 图书作者; 查询部分视图：
SELECT 作者 FROM 图书作者; 删除视图：
DROP VIEW 清华图书; 3．创建只读视图 创建只读视图要用WITH READ ONLY选项。 ​ 例：创建emp表的经理视图：
CREATE OR REPLACE VIEW manager AS SELECT * FROM emp WHERE job= &amp;#39;MANAGER&amp;#39; WITH READ ONLY; 4．使用WITH CHECK OPTION选项 使用WITH CHECK OPTION选项。使用该选项，可以对视图的插入或更新进行限制，即该数据必须满足视图定义中的子查询中的WHERE条件，否则不允许插入或更新。</description></item><item><title>Oracle笔记 （十）</title><link>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%8D%81/</link><pubDate>Thu, 30 Nov 2017 21:10:31 +0000</pubDate><guid>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%8D%81/</guid><description>建表 一、建表 格式：
如：
&amp;ndash;创建出版社表
create table 出版社（ 编号 varchar2(2), 出版社名称 varchar2(30), 地址 varchar2(30), 联系电话 varchar2(20) ）; &amp;ndash;创建图书表
create table 图书 ( 图书编号 VARCHAR2(5), 图书名称 VARCHAR2(30), 出版社编号 VARCHAR2(2), 作者 VARCHAR2(10), 出版日期 DATE, 数量 NUMBER(3), 单价 NUMBER(7,2) ); 二、通过子查询建表 步骤1：完全复制图书表到“图书1”
create table 图书1 as select * from 图书; 步骤2：创建新的图书表“图书2”，只包含书名和单价
create table 图书2（书名，单价） as seelct 图书名称，单价 from 图书； 步骤3：创建新的图书表“图书3”，只包含书名和单价，不复制内容
create table 图书3（书名，单价） as select 图书名称，单价 from 图书 where 1=2； 三、添加表的约束 方法一：建表的同时添加约束 如：</description></item><item><title>Oracle笔记 （九）</title><link>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E4%B9%9D/</link><pubDate>Wed, 29 Nov 2017 18:49:15 +0000</pubDate><guid>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E4%B9%9D/</guid><description>表的增删改操作 一、增删改 增： insert into 表名(列名) values (值)；
删： delete from 表名 where 条件；
改： update 表名 set 列名1=值1，列名2=值2... where 条件；
二、复制数据 1、通过一条查询语句创建一个新表(要求目标表不存在)
```SQL create table manager as select empno,ename,sal, from emp where job= 'CLERK'; ``` 2、通过一条查询语句复制数据(要求目标表必须已建好)
```SQL insert into manager select empno,ename,sal from emp where job = 'CLERK'; ``` 三、序列 1、创建序列 如：创建从2000起始，增量为1 的序列abc：
```SQL create sequence abc increment by 1 start with 2000 maxvalue 99999 cycle nocache; ``` 2、使用序列 序列名.</description></item><item><title>Oracle笔记 （八）</title><link>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%85%AB/</link><pubDate>Tue, 28 Nov 2017 19:10:30 +0000</pubDate><guid>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%85%AB/</guid><description>子查询、集合运算 一、子查询 通过把一个查询的结果作为另一个查询的一部分,子查询一般出现在SELECT语句的WHERE子句中，Oracle也支持在FROM或HAVING子句中出现子查询。 子查询比主查询先执行，结果作为主查询的条件，在书写上要用圆括号扩起来，并放在比较运算符的右侧。
1、单行子查询 如：查询比SCOTT工资高的雇员名字和工资。
select ename,sal from emp where sal&amp;gt;(select sal from emp where empno=7788); 2、多行子查询* 如果子查询返回多行的结果，则我们称它为多行子查询。多行子查询要使用不同的比较运算符号，它们是IN、ANY和ALL。
如:查询工资低于任意一个“CLERK”的工资的雇员信息。
select empno,ename,job,sal from emp where sal &amp;lt; any (select sal from emp where job = &amp;#39;CLERK&amp;#39;) and job &amp;lt;&amp;gt; &amp;#39;CLERK&amp;#39;; 如： 查询工资比所有的“SALESMAN”都高的雇员的编号、名字和工资。
select empno,ename,job from emp where job in (select job from emp where deptno = 10) and deptno = 20; 3.多列子查询 **如果子查询返回多列，则对应的比较条件中也应该出现多列，这种查询称为多列子查询。以下是多列子查询的训练实例。 ** 如： 查询职务和部门与SCOTT相同的雇员的信息。
select empno, ename,sal from emp where (job,deptno) = (select job,deptno from emp where empno = 7788); 4．在FROM从句中使用子查询 在FROM从句中也可以使用子查询，在原理上这与在WHERE条件中使用子查询类似。有的时候我们可能要求从雇员表中按照雇员出现的位置来检索雇员，很容易想到的是使用rownum虚列。比如我们要求显示雇员表中6～9位置上的雇员，可以用以下方法</description></item><item><title>Oracle笔记 （七）</title><link>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E4%B8%83/</link><pubDate>Mon, 27 Nov 2017 19:20:34 +0000</pubDate><guid>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E4%B8%83/</guid><description>多表连接（二）、组函数、分组查询 一、不等连接 拿一个表作为另一表的查询条件或范围
如：显示雇员名称，工资和所属工资等级。
select e.ename,e.sal,s.grade from emp e,salgrade s where e.sal between s.losal and s.hisal; 二、自连接 自连接就是一个表，同本身进行连接。对于自连接可以想像存在两个相同的表(表和表的副本)，可以通过不同的别名区别两个相同的表（其它就是内连接)
如：显示雇员名称和雇员的经理名称
select worker.ename||&amp;#39;的经理是&amp;#39;||manager.ename as 雇员经理 from emp worker,emp manager where worker.mgr=manager.empno; 三、组函数 ** 组函数只能应用于SELECT子句、HAVING子句或ORDER BY子句中。 组函数也可以称为统计函数。 组函数忽略列的空值。 对组可以应用组函数。 在组函数中可使用DISTINCT或ALL关键字。 ALL表示对所有非NULL值(可重复)进行运算。 DISTINCT 表示对每一个非NULL值，如果存在重复值，则组函数只运算一次。如果不指明上述关键字，默认为ALL。 **
函数 说明 AVG 求平均值 COUNT 求计数值，返回非空行数，*表示返回所有行 MAX 求最大值 MIN 求最小值 SUM 求和 SIDDEV 求标准偏差，是根据差的平方根得到的 VARIANCE 求统计方差 四、分组查询 1、如：按职务统计工资总和。</description></item><item><title>Oracle笔记 （六）</title><link>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%85%AD/</link><pubDate>Sun, 26 Nov 2017 19:23:25 +0000</pubDate><guid>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%85%AD/</guid><description>一、相等连接 1、三个步骤 A、先列出要显示的列： select ename,job,comm,emp,deptno,dname
B、列出查询的表： from emp,dept
C、列出多表相连条件（主外键）：where emp.deptno=dept.deptno
注意：如果两个表有同名列，那么前面必须接表名 如： emp.deptno ,如果不是同名字段则表名可以省略
2、inner join 的写法 select enaem,job,sal,comm,emp.deptno,dname from emp inner join dept on emp.deptno = dept.deptno; 3、三表或三表以上的写法 select 字段1，字段2 , 字段3 ...from 表1，表2，表3...where 表1.外键 = 表2.主键 and 表1.外键 = 表3.主键 and ... 注意：两个表有一个条件 ，三个表有两个条件 ，四个表有三个条件 以此类推
二、外连接（不等连接） 左外连接即在内连接的基础上，左边表中有但右边表中没有的记录也以null的形式显示出来，右外连接则反之
###1、写法1 (右外连接)
select ename,d.deptno,dname from emp e,dept d where e.deptno(+) = d.deptno (左外连接)
select ename,d.deptno,dname from emp e,dept d where d.</description></item><item><title>Oracle笔记 （五）</title><link>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E4%BA%94/</link><pubDate>Sat, 25 Nov 2017 19:20:38 +0000</pubDate><guid>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E4%BA%94/</guid><description>函数（二 一、日期型函数 Oracle使用内部数字格式来保存时间和日期，包括世纪、年、月、日、小时、分、秒。缺省日期格式为 DD-MON-YY，如“08-05月-03”代表2003年5月8日。
1、SYSDATE：返回系统日期和时间的虚列函数。
如：返回系统的当前日期。
SELECT sysdate FROM dual; 2、对两个日期相减，得到相隔天数。
通过加小时来增加天数，24小时为一天，如12小时可以写成12/24(或0.5)。 如：例1 假定当前的系统日期是2003年2月6日，求再过1000天的日期。
SELECT sysdate+1000 AS &amp;#34;NEW DATE&amp;#34; FROM dual; 例2：两个日期相减
select to_date(&amp;#39;1-1月-2000&amp;#39;) - to_date(&amp;#39;1-8月-1999&amp;#39;) from dual; 3、其它日期函数 |函数|功能|实例|结果| |-|-|-|-| |months_between|返回两个日期间的月份|months_between (&amp;lsquo;04-11月-05&amp;rsquo;,&amp;lsquo;11-1月-01&amp;rsquo;)57.7741935| |add_months|返回把月份数加到日期上的新日期|add_months(&amp;lsquo;06-2月-03&amp;rsquo;,1)，add_months(&amp;lsquo;06-2月-03&amp;rsquo;,-1)|06-3月-03，06-1月-03| |next_day|返回指定日期后的星期对应的新日期|next_day(&amp;lsquo;06-2月-03&amp;rsquo;,&amp;lsquo;星期一&amp;rsquo;)|10-2月-03| |last_day|返回指定日期所在的月的最后一天|last_day(&amp;lsquo;06-2月-03&amp;rsquo;)|28-2月-03| |round|按指定格式对日期进行四舍五入|round(to_date(&amp;lsquo;13-2月-03&amp;rsquo;),&amp;lsquo;YEAR&amp;rsquo;)，round(to_date(&amp;lsquo;13-2月-03&amp;rsquo;),&amp;lsquo;MONTH&amp;rsquo;)，round(to_date(&amp;lsquo;13-2月-03&amp;rsquo;),&amp;lsquo;DAY&amp;rsquo;)|01-1月-03，01-2月-03，16-2月-03(按周四舍五入)|
如：返回2003年2月的最后一天。
SELECT last_day(&amp;#39;08-2月-03&amp;#39;) FROM dual; 假定当前的系统日期是2003年2月6日，显示部门10雇员的雇佣天数。
SELECT ename, round(sysdate-hiredate) DAYS FROM emp WHERE deptno = 10; 二、转换函数 函数 功能 实例 结果 To_char 转换成字符串类型 To_char(1234.5, &amp;lsquo;$9999.9&amp;rsquo;) $1234.5 To_date 转换成日期类型 To_date(&amp;lsquo;1980-01-01&amp;rsquo;, &amp;lsquo;yyyy-mm-dd&amp;rsquo;) 01-1月-80 To_number 转换成数值类型 To_number(&amp;lsquo;1234.</description></item><item><title>Oracle笔记 （四）</title><link>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%9B%9B/</link><pubDate>Fri, 24 Nov 2017 18:02:50 +0000</pubDate><guid>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E5%9B%9B/</guid><description>条件查询、函数（一） 一、 条件查询 1、模糊查询(between、in、like)
A、between：在某某之间。如,显示工资在1000~2000之间的雇员 select * from emp where sal beteween 1000 and 2000; B、in：在某某之间。如，显示职务为“SALMAN”，“CLEARK”和“MANAGER”的雇员信息 select * from emp where job in (&amp;#39;SALMAN&amp;#39;,&amp;#39;CLERK&amp;#39;,&amp;#39;MANAGER&amp;#39;); C、like：与通配符使用 *通配符：% 代表0个或任意个字符 —_ 代表1个字符* 如：显示姓名以“S”开头的雇员信息。 select * from emp where ename like &amp;#39;S%&amp;#39;; 显示姓名第二个字符为“A”的雇员信息
select * from emp ename like &amp;#39;_A%&amp;#39;; 2、空值查询 空：is null 非空： is not null 如：查询奖金为空的雇员信息
select * from emp where comm is null; 二、函数 1、数学函数</description></item><item><title>Oracle笔记 （三）</title><link>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E4%B8%89/</link><pubDate>Thu, 23 Nov 2017 18:48:46 +0000</pubDate><guid>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E4%B8%89/</guid><description>Oracle的基本查询 一、基本查询 *select格式：*select 列名 from 表名 ； where 查询条件 group by 分组列 having 分组后条件 order by 排序列 asc[desc]
如：查询部门10的雇员 ​
select * from emp where deptno=10; 二、行号（rownum） 每个表都有一个虚列ROWNUM，它用来显示结果中记录的行号。我们在查询中也可以显示这个列。
如：显示emp表的行号
select rownum,ename from emp; 如：显示前三行
select * from emp where rownum&amp;lt;=3; 三、查询进行计算 如：显示雇员工资上浮20%的结果 ​ select ename,sal,sal*(1+20%) from emp; 如：显示每个员工的总工资（工资+奖金） ​ update emp set comm = o where comm is null; //因为null的特殊性，它与任何值运算都等于null，所以先要把它更新为0，后面我们会学到一个函数来处理null值 ​ select ename,sal+comm from emp;
四、使用别名 如：在查询中使用列别名
select ename as 名称，sal as 工资 from emp; //建议省略as 另，在别名为关键字或有特殊符号时需要加双引号</description></item><item><title>JS的时间获取</title><link>https://no-sky.github.io/2017/js%E7%9A%84%E6%97%B6%E9%97%B4%E8%8E%B7%E5%8F%96/</link><pubDate>Wed, 22 Nov 2017 13:43:49 +0000</pubDate><guid>https://no-sky.github.io/2017/js%E7%9A%84%E6%97%B6%E9%97%B4%E8%8E%B7%E5%8F%96/</guid><description>JS获取系统时间 JS自己拥有一个Date类来获取时间
var date = new Date(); 如果直接输出的话，会是这样：
2017-11-03 13:59:25Wed Nov 22 2017 13:59:25 GMT+0800 (中国标准时间) 可想而知，我们并不需要这么多的东西，所以Date类还给我们提供了一些方法来对时间进行格式化：
var year = date.getFullYear(); //获取年份 输出格式为“2017” var month = date.getMonth(); //获取月份 输出格式为“10”（类定义0~11为1~12月，所以输出10位11月，实际使用注意在后面加1） var day = date.getDate(); //获取日子（1~31） var week = date.getDay(); //获取星期 （1~7） var hour = date.getHours(); //获取小时数 var minute = date.getMinutes(); //获取分钟数 var second = date.getSeconds(); //获取秒钟 格式化时间 因为JS中不提供类似于JAVA中的SimpelDateFormat类，所以我们需要自己写一个格式化时间的方法
&amp;lt;script&amp;gt; function Format(){ var newDate=new Date(); var year=newDate.</description></item><item><title>Oracle笔记 （二）</title><link>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E4%BA%8C/</link><pubDate>Wed, 22 Nov 2017 13:23:45 +0000</pubDate><guid>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E4%BA%8C/</guid><description>一、 创建表空间 （在SqlServer中称为创建一个是数据库，而在Oracle中则称为创建一个表空间）
格式： create tablespace 表空间名 datafile &amp;lsquo;文件路径&amp;rsquo; size 文件大小
如：
cerate tablespace myspace datafile &amp;#39;D:\myspace.dbf&amp;#39; size10MB; 删除表空间：
drop tablespace myspace incluiding contents and datafile; 二、创建用户 格式： create user 用户名 identified by 密码 default tablespace 默认表空间
如：
create user user1 identified by user1 default tablespace system; 删除用户：
drop user user1 cascade; 三、给用户授权 方式一：授予角色
connect //登录 resource //普通权限，用于操作 DBA //管理员权限（慎用） 如：
grant connect to user1; grant connect,resource to user1; 方式二：授予单个权限</description></item><item><title>Oracle笔记 （一）</title><link>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E4%B8%80/</link><pubDate>Tue, 21 Nov 2017 18:33:44 +0000</pubDate><guid>https://no-sky.github.io/2017/oracle%E7%AC%94%E8%AE%B0-%E4%B8%80/</guid><description>配置Oracle 1 首先打开Oracle服务
2 配置监听器（这个是因为教室的电脑Oracle安装有问题，没有配置好监听器）开始菜单中找到net configration assistant添加一个监听器
3 用system用户登录sqlplus
4 解锁scott用户 :（也是因为教室的Oracle安装问题导致scott账户未解锁）
alter user scott account unlock; 5 修改scott密码:
alter user scott identified by tiger; 6 使用scott登录sqlplusscott是oracle自带的一个实例账户，它带有四个实例表,其中重要的就是emp员工表与dept部门表7 安装PL/SQL第三方工具因为Oracle没有自带的图形化界面管理器，所以我们需要安装PLSQL，它是oracle的一个第三方GUI工具
介绍一下Oracle的命令
连接数据库：connect scoott/tiger@orcl; &amp;ndash;用户名为scott，密码为tiger,数据库名为orcl 显示当前用户：show user;也可使用查询语句：​ select USER from dual; &amp;ndash;dual是oracle的一个虚拟表 显示表结构(以emp表为例)：describe emp;可简写为：​ desc emp;</description></item><item><title>Mysql高版本连接问题</title><link>https://no-sky.github.io/2017/mysql%E9%AB%98%E7%89%88%E6%9C%AC%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 17 Nov 2017 21:28:50 +0000</pubDate><guid>https://no-sky.github.io/2017/mysql%E9%AB%98%E7%89%88%E6%9C%AC%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/</guid><description>Java使用mysql-jdbc连接MySQL出现如下警告： 　Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &amp;lsquo;false&amp;rsquo;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification. 在mysql连接字符串url中加入ssl=true或者false即可，如下所示。
url=jdbc:mysql://127.0.0.1:3306/framework?characterEncoding=utf8&amp;amp;useSSL=true</description></item></channel></rss>